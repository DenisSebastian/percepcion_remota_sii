[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "",
    "text": "1 Introducción\nEl curso se enfoca en entregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural. Para ello se utilizará la plataforma Google Earth Engine (GEE), introduciendo el manejo básico para almacenar, visualizar y analizar imágenes satelitales."
  },
  {
    "objectID": "index.html#programa",
    "href": "index.html#programa",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "1.1 Programa",
    "text": "1.1 Programa"
  },
  {
    "objectID": "index.html#profesor-denis-berroeta-gonzález",
    "href": "index.html#profesor-denis-berroeta-gonzález",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Profesor: Denis Berroeta González",
    "text": "Profesor: Denis Berroeta González\nCoordinador de Investigación en el Centro de Inteligencia Territorial (CIT).\nemail: denis.berroeta@uai.cl\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República."
  },
  {
    "objectID": "index.html#ayudante-felipe-matas-vicent",
    "href": "index.html#ayudante-felipe-matas-vicent",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Ayudante: Felipe Matas Vicent",
    "text": "Ayudante: Felipe Matas Vicent\nAnalista de investigación y desarrollo en el Centro de Inteligencia Territorial (CIT).\nemail: felipe.matas@edu.uai.cl\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  },
  {
    "objectID": "objetivos.html#objetivo-general",
    "href": "objetivos.html#objetivo-general",
    "title": "2  Objetivos",
    "section": "2.1 Objetivo General:",
    "text": "2.1 Objetivo General:\nEl objetivo general del curso es entregar a los participantes las herramientas de análisis cuantitativo territorial, introduciendo el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine."
  },
  {
    "objectID": "objetivos.html#objetivos-específicos",
    "href": "objetivos.html#objetivos-específicos",
    "title": "2  Objetivos",
    "section": "2.2 Objetivos Específicos",
    "text": "2.2 Objetivos Específicos\n\nEntregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural.\nCapacitar a los asistentes en el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine, para manipular, sistematizar y procesar insumos provenientes de diferentes sensores satelitales.\nEntregar a los asistentes las capacidades metodológicas base para el diseño y la construcción de un conjunto de índices espectrales e indicadores ambientales, utilizando la imaginería satelital disponible a la comunidad."
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-teóricos",
    "href": "fundamentos_PR.html#conceptos-teóricos",
    "title": "3  S1: Percepción Remota",
    "section": "3.1 Conceptos Teóricos",
    "text": "3.1 Conceptos Teóricos\n\n3.1.1 Definición de Percepción Remota\nLa Percepción Remota es una disciplina científica que, en la actualidad, se presenta como una herramienta clave para el estudio de la Tierra y su entorno. Esta disciplina proporciona un amplio conjunto de conocimientos y tecnologías utilizados para la observación, el análisis y la interpretación de fenómenos en la superficie terrestre.\nEn términos generales, la Percepción Remota nos permite llevar a cabo observaciones y mediciones mediante dispositivos remotos, como satélites, aviones y drones. Los sensores instalados en estas plataformas miden una gran variedad de datos, entre ellos radiaciones electromagnéticas, espectro electromagnético, perturbaciones atmosféricas, firmas espectrales y captura de imágenes.\nLa Percepción Remota se ha convertido en una disciplina fundamental para el estudio de la Tierra y su entorno, y su aplicación en la investigación y la gestión de recursos naturales ha demostrado ser de gran utilidad en la toma de decisiones en distintos ámbitos. En este sentido, el desarrollo de tecnologías cada vez más sofisticadas y eficientes en la captura y procesamiento de datos, así como la creciente cantidad de información disponible, hacen que la Percepción Remota siga siendo un campo en constante evolución y con un gran potencial para el futuro.\n\n\n\n\n\n\n\n3.1.2 Aplicaciones de la PR\nLa importancia de la Percepción Remota radica en su capacidad para capturar información valiosa sobre la superficie terrestre, lo que ha permitido importantes avances en áreas como la agricultura, la geología, la climatología y la gestión de recursos naturales. Por ejemplo, gracias a la Percepción Remota, hoy en día es posible monitorear la salud de los cultivos y prevenir enfermedades, identificar zonas de riesgo para la exploración de recursos minerales y petroleros, predecir desastres naturales y monitorear los efectos del cambio climático. A continuación se describen algunos ejemplos de usos de la perceción remota:\nMonitoreo Ambiental:\n\nBosque Nativo: Superficie anual, Vigor vegetacional Desforestación\nContaminación de Recursos Naturales: Borde Costero, red clorhídrica, cuerpos de agua, suelos, aire.\nGlaciares: Superficie de cuerpos glaciares\nHumedales Alto Andino: Superficie anual vegetada e inundada en el humedal\n\nMonitoreo Urbano:\n\nCrecimiento urbano: Superficie urbana cambios en la ciudades y planificación\nCrecimiento rural: Superficie urbana cambios en la ruralidad\nCrecimiento asentamientos irregulares: Crecimiento de las asentamientos informales\n\nDesastres Naturales:\n\nIncendios Forestales: Estimación de superficie afectada\nTerremotos y Tsunamis: Estimación de daños gestión de riesgos\nDeslizamientos de Tierra: Estimación de superficie afectada\nAluviones: Estimación de superficie afectada\nEmergencias Volcánicas: Estimación de superficie afectada\n\nIndustrias:\n\nForestal: Estimación de superficie afectada\nMinería: Estimación de superficie afectada\nAgrícola: Estimación de superficie afectada\n\n\n\n\n3.1.3 ¿Qué es la Percepción Remota?\nLa medición de una cantidad asociada con un objeto por un aparato no en contacto directo con el objeto.\nAparatos: Antena, vehículo aéreo, satélites.\n\n\n\n\n\n¿Qué se mide la percepción remota satelital?\nLa percepción remota satelital utiliza instrumentos y sensores para medir la radiación electromagnética proveniente del sistema tierra-atmósfera. La intensidad de la radiación reflejada y emitida al espacio está influenciada por las condiciones en la superficie y la atmósfera.\n\n\n\n\n\nLa radiación electromagnética producida por el Sol es la energía que emite en forma de ondas electromagnéticas. Esta radiación se divide en diferentes tipos según su longitud de onda, como los rayos X, los rayos gamma, la luz visible, las ondas de radio, entre otros.\nLa atmósfera terrestre juega un papel importante en la radiación electromagnética que llega a la superficie terrestre. Parte de la radiación es absorbida por la atmósfera, mientras que otra parte es reflejada y dispersada en diferentes direcciones. El efecto de la atmósfera puede modificar la intensidad de la radiación que llega a la superficie terrestre y puede afectar las mediciones realizadas por los dispositivos de percepción remota. Por esta razón, es importante tener en cuenta las condiciones atmosféricas al interpretar las mediciones de sensores remotos.\n\n\n3.1.4 Radiación Electromagnética\nEl principio básico se basa en que todos los cuerpos emiten radiación electromagnética, el tipo y la cantidad depende principalmente de la temperatura del cuerpo (Figure 3.1).\nEl principal emisor de radiación es el Sol, cuyo reflejo en la superficie y atmósfera terrestre nos permite ver y analizar los objetos a nuestro alrededor.\n\n\n\nFigure 3.1: La vegetación verde, absorbe las ondas azules (B) y rojas (R) y refleja las verdes (G) e infrarrojas (IR)\n\n\n\n\n3.1.5 Espectro Electromanético\nEl espectro electromagnético es el conjunto de todas las ondas electromagnéticas que existen, desde las ondas de radio hasta los rayos gamma (Figure 3.2). Cada tipo de onda electromagnética tiene una longitud de onda y una frecuencia específicas que determinan su ubicación en el espectro. Las ondas de radio tienen la longitud de onda más larga y la frecuencia más baja, mientras que los rayos gamma tienen la longitud de onda más corta y la frecuencia más alta.\nLa percepción remota satelital se basa en la medición de la radiación electromagnética que emiten los objetos de la superficie terrestre, y los sensores instalados en los satélites miden la radiación en diferentes longitudes de onda para obtener información sobre la composición y las características de los objetos que se están observando.\n\n\n\nFigure 3.2: Espectro Electromanético\n\n\n\n\n3.1.6 Firmas Espectrales\nUna vez que la energía electromagnética llega a la superficie terrestre, interactúa con cada tipo de material ya sea por reflexión, absorción o transmisión, de acuerdo a un patrón de respuesta espectral particular. Este comportamiento distintivo de cada tipo de material es aprovechado en procesos de clasificación de imágenes, siendo común referirse a él como “firma espectral”.\n\n\n\nEjemplo: Vegetación Sana, tiene peaks en Banda Verde (550 nm) y comienzo del Banda Infrarroja (750 nm)"
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "href": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 Conceptos Prácticos sobre Raster",
    "text": "3.2 Conceptos Prácticos sobre Raster\nLa estructura matemática mínima de una imagen es una matriz, para operar operar sobre ella la usaremos a un nivel más complejo llamado raster. En el contexto de la percepción remota satelital, las imágenes se pueden representar como una matriz de píxeles, donde cada píxel se identifica por su ubicación en la fila y columna correspondiente de la matriz. Al analizar las propiedades de los píxeles, como su valor de reflectancia o su firma espectral, se puede obtener información sobre las características de los objetos que se están observando en la imagen.\n\n3.2.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.2.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información.\n\n\n\n\n\n3.2.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.2.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano\n\n\n\n\n\n3.2.5 Clases Matriz y Array en R\nUna matriz es una estructura matemática muy común en la cual se representan datos en forma de arreglos rectangulares de números o símbolos. Las matrices se componen de filas y columnas, y cada entrada en la matriz se identifica por su posición en la fila y columna correspondiente.\nUn raster multibanda es un array de tres dimensiones con información de referencia espacial. Por lo anterior, debemos cubrir estos tipos de estructuras de datos en R.\n\n\n3.2.6 Matrix\nSe crea con la función matrix\n\nmi_matriz <- matrix(ncol= 3,nrow = 3) # crear una matriz vacía\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# image(mi_matriz)\n\n\n\nvalores <- 1:9 # definir valores que contendrá mi matriz\nmi_matriz[] <- valores # asignación de valores a una matrix (forma no recomendada)\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# \n\nmi_matriz <- matrix(data = valores, ncol= 3, nrow = 3) # crear una matriz\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n\nla función matrix, tiene los siguientes argumentos:\n\ndata: The vector of values for the matrix (for example, 1:6)\nnrow: The number of rows\nncol: The number of columns (for example, 3)\nbyrow: Whether the matrix is filled column by column (FALSE, which is the default value) or row by row (TRUE)\n\nPara construir la misma matriz, utilizaremos el parámetro nrow (número de filas)\n\nvalores <- 1:6\nvalores\n\n[1] 1 2 3 4 5 6\n\nmatrix(valores, nrow = 2) #mismo resultado\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nComo se observa nosotros asignamos los valores que contiene la matriz, y se pasan como un vector, donde la matriz será llenada de acuerdo a los argumentos que le entreguemos:\n\n#le pasamos un vector de largo 12 (12:1), pero existen solo 8 espacias para almacenar información\nvalores <- 12:1\nvalores\n\n [1] 12 11 10  9  8  7  6  5  4  3  2  1\n\nmatrix(valores, ncol = 4, nrow = 2)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12   10    8    6\n[2,]   11    9    7    5\n\n# en este caso los espacios de almacenamiento de información es 16, mayor a los 12 que nosotros dimos\n# comienza a rellenar desde el principio del vector dado (12:1)\nmatrix(valores, ncol = 4, nrow = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12    8    4   12\n[2,]   11    7    3   11\n[3,]   10    6    2   10\n[4,]    9    5    1    9\n\n\nFunciones básicas sobre las matrices (similar a Dataframe)\n\nvalores <- 7:12\nvalores\n\n[1]  7  8  9 10 11 12\n\nx <- matrix(valores, ncol = 3, byrow = TRUE)\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nnrow(x) # consultar número de filas\n\n[1] 2\n\nncol(x) # consultar número de columnas\n\n[1] 3\n\ndim(x) # consultar número de dimensiones\n\n[1] 2 3\n\nvector_x <- as.vector(x) # reconvertir a vector\n\nSubset sobre una Matriz\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nx[, c(1,3)] # leer todas las filas, y columnas 1 y 3\n\n     [,1] [,2]\n[1,]    7    9\n[2,]   10   12\n\nx[2, ] # devolver fila 2 como vector \n\n[1] 10 11 12\n\nx[2, , drop = FALSE] # devolver fila 2 como dataframe\n\n     [,1] [,2] [,3]\n[1,]   10   11   12\n\n\nTrasponer una matriz\n\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nt(mi_matriz)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nAplicar funciones con apply() sobre una matriz\n\napply(x, 2, mean) # aplicar funciones estadísticas o propias\n\n[1]  8.5  9.5 10.5\n\n\nFunciones de alto performance (escritas en c++)\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\ncolSums(x) #suma de columnas\n\n[1] 17 19 21\n\ncolMeans(x) # promedio por columna\n\n[1]  8.5  9.5 10.5\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nrowSums(x) #Suma por fila\n\n[1] 24 33\n\nrowMeans(x) # promedio por fila\n\n[1]  8 11\n\n# PD: sirven también para dataframe y arrays\n\nEjemplo de martiz sin referencia espacial\n\n# class(volcano)\n# dim(volcano)\nimage(volcano, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\ncontour(volcano, add = TRUE)\n\n\n\n\n\n# install.packages(\"plot3D\")\nlibrary(plot3D)\n# reducir dimensionalidad\nVolcano <- volcano[seq(1, nrow(volcano), by = 3),\n                     seq(1, ncol(volcano), by = 3)]\n\npersp(Volcano, theta = 40, phi = 40, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nsubset\n\nr30 = volcano[30, ]  # Row 30\nr70 = volcano[70, ]  # Row 70\nplot(r30, type = \"l\", col = \"blue\", ylim = range(c(r30, r70)), ylab = \"Elevation (m)\")\nlines(r70, type = \"l\", col = \"red\")\n\n\n\n\n\n\n3.2.7 Arrays\n\n\n\nRepresentan estructuras de datos con dos o mas dimensiones, y se crean con la función “array”. Crearemos un objeto de 2 filas, 2 columnas y 3 dimensiones.\n\n# ?array\nvalores <- 1:24\nvalores\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ny <- array(data = valores, dim =  c(2,4,3)) # dim(n_filas, , n_col, n_dimensiones(capas)) \ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\n\nSubset un array\n\ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\ny[2,1,3] # seleccionar fila 2, columna 1, dimensión 3\n\n[1] 18\n\ny[2,1,] # seleccionar fila 2, columna 1, de todas las dimensiones\n\n[1]  2 10 18\n\n\n\n\n3.2.8 Estructura de Datos de Raster\nUn raster es una grilla rectangular de valores numéricos referenciados en cierta extensión geográfica. Puede tener una (matriz) o múltiples bandas (arrays).\nEn R para el tratamiento de objetos Raster se utiliza el package raster, de acuerdo a contenidos programadas de esta clase solo veremos las funciones básicas, pero con ejemplos que representa el mundo real.\nCaracterística importante del package raster que tienen la capacidad de trabajar con grandes raster (de mayor peso que la RAM de nuestros Equipos), donde automáticamente escribe el archivo temporal en el disco duro.\n\n\n\n\n\nlibrary(raster)\n\nz <- raster() # crear un raster vacio\nz\n\nclass      : RasterLayer \ndimensions : 180, 360, 64800  (nrow, ncol, ncell)\nresolution : 1, 1  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs"
  },
  {
    "objectID": "fundamentos_PR.html#sec-crearRaster",
    "href": "fundamentos_PR.html#sec-crearRaster",
    "title": "3  S1: Percepción Remota",
    "section": "3.3 Crear Raster",
    "text": "3.3 Crear Raster\nagregar argumentos\n\n?raster()\nx <- raster(ncol=36, nrow=18, # cantidad de filas y columnas\n            xmn=-1000, xmx=1000, ymn=-100, ymx=900)# extent (representación espacial)\nx\n\nclass      : RasterLayer \ndimensions : 18, 36, 648  (nrow, ncol, ncell)\nresolution : 55.55556, 55.55556  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n# plot(x)\n\nResolución espacial\n\nres(x)\n\n[1] 55.55556 55.55556\n\nres(x) <- 100\nres(x)\n\n[1] 100 100\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 20, 200  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n\nCambiar Numero de columnas (afecta la resolución)\n\nncol(x)\n\n[1] 20\n\nncol(x) <- 18\nncol(x)\n\n[1] 18\n\nres(x)\n\n[1] 111.1111 100.0000\n\n\ndefinir sistema de referencia de coordenadas\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nprojection(x) <- crs_latlon\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\nPero Hasta acá nuestro objeto Raster no tiene valores\n\nhasValues(x) # consultar si raster tiene valores\n\n[1] FALSE\n\nncell(x) #cantidad de celdas\n\n[1] 180\n\nvalues(x) <- 1:ncell(x) # ncell (cantidad de celdas del raster)\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nVisualización\n\nlibrary(RColorBrewer)\n# display.brewer.all()\ncolores <- brewer.pal(n = 8, name = 'BrBG') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(c(colores))( 180 ) # 200 colores \nplot(x, col = pal_col)\n\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nmodificación de valores del Raster\n\nset.seed(42)\nvalues(x) <- runif(ncell(x))\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nFunciones\n\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1] 111.1111 100.0000\n\ndim(x)\n\n[1] 10 18  1\n\nxmax(x)\n\n[1] 1000\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n\nCambiar el maximum de la coordenada x del extent (bounding box)\n\nxmax(x) <- 0\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1]  55.55556 100.00000\n\ndim(x)\n\n[1] 10 18  1\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 55.55556, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nsi modifico ncol desaparece los valores\n\nncol(x) <- 10\nhasValues(x)\n\n[1] TRUE\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n# plot(x, col = pal_col)\n\n\n3.3.1 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, !\nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\n\n\n3.3.2 Funciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\n\n\n3.3.3 Reclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)\n\n\n\n\n\n\n3.3.4 Crear Raster Mulitibanda\n\n\n\nPara crear una raster multibanda (RasterLayer) utilizaremos la función stack()\n\nr1 <- r2 <- r3 <- raster(nrow=10, ncol=10)\n# Assign random cell values\nvalues(r1) <- runif(ncell(r1))\nvalues(r2) <- runif(ncell(r2))\nvalues(r3) <- runif(ncell(r3))\n\ns <- stack(r1, r2, r3)\ns\n\nclass      : RasterStack \ndimensions : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)\nresolution : 36, 18  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :      layer.1,      layer.2,      layer.3 \nmin values : 0.0023781068, 0.0014338985, 0.0004050434 \nmax values :    0.9907958,    0.9802787,    0.9930453 \n\nnlayers(s)\n\n[1] 3\n\n\n\nb1 <- brick(r1, r2, r3)\n\nLeer un raster de ejemplo\n\nfilename <- system.file(\"external/test.grd\", package=\"raster\")\nfilename\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/raster/external/test.grd\"\n\nr_test <- raster(filename)\n# filename(r)\nhasValues(r_test)\n\n[1] TRUE\n\nplot(r_test, main='RasterLayer from file', col = pal_col)\n\n\n\n\n\nr1 <- r_test\nr2  <- calc(r_test, fun=function(x){ x[x < 500] <- NA; return(x)})\n\nr3 <- reclassify(x = r_test,\n                          rcl = c(0,300,1, \n                                  300,500,2, \n                                  500,1000,3,\n                                  1000, 2000, 4))\n\nbrick_raster <- brick(r1, r2, r3)\n\nVisualización dinámica\n\nlibrary(mapview)\npal = mapviewPalette(\"mapviewTopoColors\")\nm <- mapview(brick_raster, alpha = 0.5)\nm@map\n\n\n\n\n\n\n\n3.3.5 Guardar Raster\n\n# dir.create(path = \"data/raster\")\nwriteRaster(r_test, \"data/r_test1.tif\")"
  },
  {
    "objectID": "intro_R.html#qué-es-r-project",
    "href": "intro_R.html#qué-es-r-project",
    "title": "4  Introducción a R",
    "section": "4.1 ¿Qué es R Project?",
    "text": "4.1 ¿Qué es R Project?\nR es un lenguaje programación multiparadigma (procedural, imperativo, orientado a objetos y funcional) enfocado a aplicaciones estadísticas. Por estadísticas se debe entender también los campos de estudio que se basan o las utilizan como económía, finanzas, ciencia de datos, machine learning, etc.\n\n4.1.1 Ventajas de Utilizar R Project\n1. R es un software libre\n\nLa libertad de ejecutar el programa como desee y con cualquier propósito\nEstudiar el funcionamiento del programa y adaptarlo a sus necesidades.\nRescribir copias para ayudar a los demás.\nManejar el programa y publicar las mejorar, de manera que toda comunidad se beneficie.\n\n2. R es multiplataforma\n\nR funciona en Mac, Windows y en numerosos sistemas UNIX. Esto significa que cualquier persona puede trabajar con tus datos, figuras, análisis y más importante aún usar tus instrucciones (también conocido como scripts o código) para generar las figuras y el análisis. Así que cualquier persona, y en cualquier lugar del mundo, con acceso a cualquier SO puede usar R sin ninguna licencia.\n\n3. R es de código abierto\n\nExiste una gran comunidad de voluntarios trabajando para mejorarlo, lo cual permite ser moldeado y dirigido a cuestiones específicas. Creando así programas y paquetes que funcionen en el entorno R. Programas tales como R-studio, Java GUI for R, R- commander, RKWard, entre otros, y con más de 18000 paquetes indexado en CRAN, Biocoductor, GitHub y R-Forge.\n\n4. Todo dentro de un mismo entorno\n\nR remplaza la combinación de varios programas para el proceso de análisis de datos, por ejemplo Excel, ArcGis, QGis, SigmaPlot, entre otros. Esto no solo resulta en el alto costo de las licencias de múltiples programas, si no también, en la gran cantidad de archivos con diferentes formatos que no podrían leer otros programas. En cambio con solo utilizar R, puedes realizar todo el análisis de datos e inclusive leer archivos de diferentes formatos.\n\n\n\n4.1.2 Desventajas de utilizar R\n\nR tiene una vasta documentación de ayuda, descripción de paquetes y de funciones, que es difícil encontrar información específica en un momento dado.\nLos mensajes de error que R nos muestra, no es específica sobre los fallos que estamos realizando y solo un usuario con cierta experiencia en el uso de R puede saberlo."
  },
  {
    "objectID": "intro_R.html#instalación-de-r-project",
    "href": "intro_R.html#instalación-de-r-project",
    "title": "4  Introducción a R",
    "section": "4.2 Instalación de R Project",
    "text": "4.2 Instalación de R Project\n\n4.2.1 Instalación de R Project\nPrimero se debe instalar R Project desde su sitio oficial (https://cran.r-project.org/bin/windows/base/), se ejecuta el instalador que se descargó depende del sistema operativo del PC, como se muestra en las siguientes figuras:\n\n\n\n4.2.2 Instalación de R para Windows\n\n\n\n\n\n4.2.3 Instalar Rtools (solo Sistema Operativo Windows)\n\n\n\n\n\n\n\n\n4.2.4 Instalación de R para Mac\n\n\n\nR Project Ejecutándose"
  },
  {
    "objectID": "intro_R.html#instalación-de-rstudio",
    "href": "intro_R.html#instalación-de-rstudio",
    "title": "4  Introducción a R",
    "section": "4.3 Instalación de RStudio",
    "text": "4.3 Instalación de RStudio\nSe recomienta instalar Rstudio, que es Interfaz de Usuario de R Project, desde su sitio web oficial, el cual permite acceder con mayor facilidad a sus funciones y potencialidades de R.\n\n\n\n\n\n\n\n\n\n4.3.1 RStudio Cloud\nRStudio Cloud es una versión ligera del IDE RStudio alojada en la la nube que permite a cualquiera hacer, compartir, enseñar y aprender Ciencias de Datos Online. Tiene una versión gratuita limitada.\n\n4.3.1.1 Características:\n\nAnalyze your data using the RStudio IDE, directly from your browser.\nShare projects with your team, class, workshop or the world.\nTeach data science with R to your students or colleagues.\nLearn data science in an instructor-led environment or with interactive tutorials."
  },
  {
    "objectID": "intro_R.html#instalar-librerías",
    "href": "intro_R.html#instalar-librerías",
    "title": "4  Introducción a R",
    "section": "4.4 Instalar Librerías",
    "text": "4.4 Instalar Librerías\n\n4.4.1 Librerías en R\nLas librerías o paquetes en R corresponden a una colección de funciones encapsuladas y diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, mineria de datos, interacción con servicios de internet y muchas otras cosas más.\nEstos paquetes se encuentran alojados principalmente en CRAN (Comprehensive R Archive Network), así que pasan por un control riguroso antes de estar disponibles para su uso generalizado, al día de hoy (29.11.2021) existen 18498 paquetes disponibles. En el siguiente enlace se deja una lista de temas y sus librerías asociadas disponibles, con una breve descripción (enlace)\nAunque las versiones de prueba de una librería pueden estar disponible en Github (Respositorio de Control de Versiones) de cada autor.\n\n\n4.4.2 Ejemplo de Instalación de Librerías desde R\nPodemos instalar paquetes usando la función install.packages(), dando como argumento el nombre del paquete que deseamos instalar, entre comillas.\nPara instalar librerías se puede hacer directamente desde la consola de RStudio, por ejemplo:\n\ninstall.packages(\"dplyr\") # Se puede instalar más de una librería a la vez\n\n\n\n4.4.3 Ejemplo de Instalación de Librerías desde Rstudio\nTambién se pude instalar librerías del Panel “Packages”\n\n\n\nY por último se puede instalar desde Pestaña “Tools” -> “Install Packages”:"
  },
  {
    "objectID": "intro_R.html#definición-de-directorios-de-trabajos",
    "href": "intro_R.html#definición-de-directorios-de-trabajos",
    "title": "4  Introducción a R",
    "section": "4.5 Definición de Directorios de Trabajos",
    "text": "4.5 Definición de Directorios de Trabajos\nDefinir directorio de Trabajo con RStudio\n\n\n\n\n\n\nDefinir Directorio de Trabajo con una función\n\nsetwd(\"~/OneDrive - Universidad Adolfo Ibanez/CIT/DOCENCIA/CLASES_SII/\")\n\nConsultar Directorio de Trabajo\n\ngetwd()\n\n[1] \"/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII\""
  },
  {
    "objectID": "variables_R.html#tipos-de-objetos-en-r",
    "href": "variables_R.html#tipos-de-objetos-en-r",
    "title": "5  Variables en R",
    "section": "5.1 Tipos de Objetos en R",
    "text": "5.1 Tipos de Objetos en R\nLos Datos en R se pueden clasificar por su dimensiones y los tipos de Datos que permiten almacenar, como se muestra en la siguiente tabla:\n\n\n\nDimensiones\nHomogéneos\nHeterogéneos\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\nFuente: http://adv-r.had.co.nz/Data-structures.html\nR nos permite definir variables que pueden ser luego usadas en las distintas operaciones. El lenguaje no solo permite definir escalares (variable de un numero), si no también variables que sean un conjunto de numero o caracteres ordenados.\n\n5.1.1 Variables Numéricas\n\n# La asignación en R son válidos 2 métodos '<-' o '='\nx <- 7 # Definir variable (escalar) x que sea igual a 7\nx # Mostrar que es x\n\n[1] 7\n\ny <- 3 + 2 * x # Crear y como funcion de x \ny\n\n[1] 17\n\nclass(y)\n\n[1] \"numeric\"\n\n\nNúmeros Random con decimales\n\nru <- runif(n = 100, min = 1, max = 10)\nru\n\n  [1] 8.315020 2.801009 6.177692 4.366734 3.755047 3.806788 6.124477 9.630987\n  [9] 7.259577 4.840344 1.934428 6.115044 3.393551 9.055921 9.440785 8.794495\n [17] 7.693674 2.287188 7.549130 9.055910 4.699799 5.680732 2.485013 3.124626\n [25] 4.612829 5.071542 2.572648 8.880720 2.101669 4.730377 6.352730 7.991968\n [33] 1.176312 2.657698 6.998075 5.019458 8.642314 8.449694 1.074048 8.842926\n [41] 9.129757 4.991725 4.443086 8.521112 4.568566 9.088141 5.632828 2.098411\n [49] 4.620796 2.384418 8.195105 1.867798 5.896476 7.023919 1.120919 5.507175\n [57] 2.245327 9.043002 7.211708 7.390625 2.490903 8.359944 8.808764 7.892855\n [65] 2.793631 2.164417 5.860104 8.017518 9.915129 8.432961 9.109597 5.811628\n [73] 9.234334 8.395389 1.744740 2.231811 2.317130 6.283394 1.135348 3.311190\n [81] 1.889638 4.021137 4.495284 2.004904 9.056858 6.806635 7.016193 8.966180\n [89] 4.748942 4.811928 4.458273 5.326447 2.050705 9.304847 9.593750 2.935762\n [97] 6.055577 8.700428 3.251589 3.598496\n\n\n\nhist(ru, breaks = 20, col = \"orange\", border = \"gray60\", \n     main = \"Histograma de valores Random\")\n\n\n\n\n\n\n\n\nNúmeros Random Enteros\nSimular los lanzamientos de un dado\n\nsample.int(n = 6, size = 10, replace = T)\n\n [1] 2 5 4 5 2 4 5 1 5 2\n\n\n\n\n5.1.2 Variables de Caracter\n\nch <- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn <- \"Santiago\"\nch # Mostrar ch\n\n[1] \"Chile\"\n\nsn\n\n[1] \"Santiago\"\n\n\nUnir variables de texto con paste()\n\nch <- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn <- \"Santiago\"\nunion <- paste(sn,ch, sep = \", \")\nunion\n\n[1] \"Santiago, Chile\"\n\n\nUtilizar paste0()\n\nunion <- paste(\"Provincia de \", sn,ch, sep = \", \")\nunion\n\n[1] \"Provincia de , Santiago, Chile\"\n\nunion0 <- paste0(\"Provincia de \", sn, \", \", ch)\nunion0\n\n[1] \"Provincia de Santiago, Chile\"\n\n\nBuscar y reemplazar con gsub\n\nav <- \"Av. Apoquindo\"\ncomuna <- \"comuna de Las Condes\"\ncalle <- paste(av, comuna, union0, sep = \", \")\ncalle\n\n[1] \"Av. Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\"\n\n# reemplazar Av. por Avenida\ncalle_new <- gsub(pattern = \"Av.\", replacement = \"Avenida\", x = calle)\ncalle_new\n\n[1] \"Avenida Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\""
  },
  {
    "objectID": "variables_R.html#estructuras-de-datos",
    "href": "variables_R.html#estructuras-de-datos",
    "title": "5  Variables en R",
    "section": "5.2 Estructuras de Datos",
    "text": "5.2 Estructuras de Datos\nLas variables pueden ser un conjunto de números y caracteres ordenados de varias maneras. El orden que se les da depende de lo que queremos lograr con estos.\n\n5.2.1 Vectores\nLa estructura ordenada mas simple y común es el vector:\n\nvec <-  c(4, 3, 1, 5, 8, 16)\nvec\n\n[1]  4  3  1  5  8 16\n\nclass(vec)\n\n[1] \"numeric\"\n\nstr(vec)\n\n num [1:6] 4 3 1 5 8 16\n\n\nPodemos seleccionar parte del vector:\n\n# EL primer índice en R es 1 (en otros lenguajes de programación es 0)\nvec[3]\n\n[1] 1\n\n\nLa selección también puede ser hecha con una condición, de tal manera que solo seleccione aquella parte del vector que cumple con la condición.\nMayor a:\n\nvec[vec >= 4]\n\n[1]  4  5  8 16\n\n\nContenido en:\n\nvec[vec %in% c(3, 8, 7, 29)]\n\n[1] 3 8\n\n\nNegación de la condición:\n\nvec[!vec <= 3]\n\n[1]  4  5  8 16\n\n\nTambién podemos realizar operaciones matemáticas simples aplicadas al vector, por ejemplo una suma:\n\nvec2  <-  c(7, 10, 1)\nvec + vec2\n\n[1] 11 13  2 12 18 17\n\n\n\n\n5.2.2 Listas\nSon estructuras eficientes y flexibles, que permiten combinar distintas clases de elementos :\n\nlista <-  list(1, 2, 3, \"cosa\", x, y)\nlista\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"cosa\"\n\n[[5]]\n[1] 7\n\n[[6]]\n[1] 17\n\nstr(lista)\n\nList of 6\n $ : num 1\n $ : num 2\n $ : num 3\n $ : chr \"cosa\"\n $ : num 7\n $ : num 17\n\n\n\n#Tambien se puede seleccionar parte de una lista, usando el doble corchete:\nlista[[3]]\n\n[1] 3\n\n\nComo inspeccionar una lista con Rstudio\n\n\n\n\n\n5.2.3 Matrices\nSon estructuras de datos con 2 dimensiones, horizontal y la vertical (filas y columnas). Podemos construirlas usando la función “matrix”, con un vector inicial y sus dimensiones:\n\nn <- matrix(c(1.3, 2.8, 3.5, 6.4, 5.3, 6.2, 7, 4.5, 2.4, 6.3, 5.6, 5.3, 6.6, 7, 4.3),\n  nrow = 5, ncol = 3, byrow = TRUE)\nn\n\n     [,1] [,2] [,3]\n[1,]  1.3  2.8  3.5\n[2,]  6.4  5.3  6.2\n[3,]  7.0  4.5  2.4\n[4,]  6.3  5.6  5.3\n[5,]  6.6  7.0  4.3\n\n\nLa matriz tiene 2 dimensiones, por lo que para seleccionar partes de ella es necesario declarar dos dimensiones separadas por una coma. A la izquierda van las filas y a la derecha las columnas. Un valor vacío indica que se seleccionan todos los valores posibles.\n\nn[1,2]\n\n[1] 2.8\n\n\n\nn[,3]\n\n[1] 3.5 6.2 2.4 5.3 4.3\n\n\n\n\n5.2.4 Dataframes\nEstructura mas clásica de datos, es una matriz pero con mas atributos como nombres de columna y/o fila. Es lo mas similar en R a una tabla excel o la tabla de atributos. La manera mas simple de crear un dataframe es a partir de una matriz usando la función as.data.frame() :\n\ndf<- as.data.frame(n)\ndf\n\n   V1  V2  V3\n1 1.3 2.8 3.5\n2 6.4 5.3 6.2\n3 7.0 4.5 2.4\n4 6.3 5.6 5.3\n5 6.6 7.0 4.3\n\n\nPodemos asignar nombres a las columnas del dataframe\n\nnames(df)<- c(\"control_1\",\"control_2\",\"examen\")\ndf\n\n  control_1 control_2 examen\n1       1.3       2.8    3.5\n2       6.4       5.3    6.2\n3       7.0       4.5    2.4\n4       6.3       5.6    5.3\n5       6.6       7.0    4.3\n\n\nY a las filas del dataframe\n\ndf$alumno <- c(\"Sofia\",\"Tomas\",\"Luciano\",\"Julian\",\"Gabriela\")\ndf\n\n  control_1 control_2 examen   alumno\n1       1.3       2.8    3.5    Sofia\n2       6.4       5.3    6.2    Tomas\n3       7.0       4.5    2.4  Luciano\n4       6.3       5.6    5.3   Julian\n5       6.6       7.0    4.3 Gabriela\n\n\nTambién podemos realizar operaciones entre vectores del dataframe:\n\ndf$promedio_final <-  0.3*df$control_1 + 0.3*df$control_2 + 0.4*df$examen\ndf\n\n  control_1 control_2 examen   alumno promedio_final\n1       1.3       2.8    3.5    Sofia           2.63\n2       6.4       5.3    6.2    Tomas           5.99\n3       7.0       4.5    2.4  Luciano           4.41\n4       6.3       5.6    5.3   Julian           5.69\n5       6.6       7.0    4.3 Gabriela           5.80"
  },
  {
    "objectID": "funciones.html#funciones-báscias",
    "href": "funciones.html#funciones-báscias",
    "title": "6  Funciones en R",
    "section": "6.1 Funciones Báscias",
    "text": "6.1 Funciones Báscias\nR nos permite hacer todo tipo de operaciones matematicas, desde las mas simples a las mas complejas.\n\nOperaciones Básicas : +, -, *, /\nOperadores Lógicos >, >=, <, ==, !\nOtras Funciones: abs, round, ceiling, floor, +, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\na <- 13\nb <- c(20,30,22,2,1)\n\nsum(b) # suma\n\n[1] 75\n\nsqrt(b) # find the square root of x\n\n[1] 4.472136 5.477226 4.690416 1.414214 1.000000\n\n\n\nmean(b)\n\n[1] 15\n\nmin(b)\n\n[1] 1\n\nmax(b)\n\n[1] 30\n\n\nOtras funciones\n\n# log()\n# abs()\n# sin(), cos(), tan(), and others\n# sum(), cumsum(), prod(), cumprod()\n# max(), min()"
  },
  {
    "objectID": "funciones.html#funciones-útiles-de-propósito-general",
    "href": "funciones.html#funciones-útiles-de-propósito-general",
    "title": "6  Funciones en R",
    "section": "6.2 Funciones Útiles de propósito general",
    "text": "6.2 Funciones Útiles de propósito general\n\nrep(1, 10)\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrep(\"HAHA\", 10)\n\n [1] \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\"\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by = 2)\n\n[1] 1 3 5 7 9\n\nifelse(3 > 5, 1, \"this is false\")\n\n[1] \"this is false\"\n\n\n\npaste(\"Hola\", \"amigo\")\n\n[1] \"Hola amigo\"\n\npaste(\"Hello\", \"amigo\", sep = \"--\")\n\n[1] \"Hello--amigo\"\n\npaste0(\"Hello\", \"amigo\")\n\n[1] \"Helloamigo\"\n\ntolower(\"HAHAHAHAH\")\n\n[1] \"hahahahah\"\n\ntoupper(\"hueuehuehuheuhe\")\n\n[1] \"HUEUEHUEHUHEUHE\""
  },
  {
    "objectID": "funciones.html#crear-funciones-propias",
    "href": "funciones.html#crear-funciones-propias",
    "title": "6  Funciones en R",
    "section": "6.3 Crear Funciones Propias",
    "text": "6.3 Crear Funciones Propias\n\na <- 13\nb <- c(20,30,22,2,1)\n\ncuadrado <- function(x) { # x = parámetro\n    y = x ^ 2 # asiganción de variables solo dentro de la función\n    return(y) # especificar valor retornado (no necesario completamente)\n}\n\ncuadrado(a)\n\n[1] 169\n\ncuadrado(b)\n\n[1] 400 900 484   4   1\n\n\nActividad: Crear una función que calcule la hipotenusa de un triángulo rectángulo (Teorema de Pitágoras):\n\n\n\nEstablece que el cuadrado de la longitud de la hipotenusa es igual a la suma de los cuadrados de las longitudes de los catetos.\nc^2 = {a^2}+{b^2}\nPor lo cual:\nc = \\sqrt{{a^2}+{b^2}}\nAyuda\n\nhipotenusa <- function(a, b){\n  #h <-     # En esta parte escribir la función\n  return(h)\n}\nr1 <-  hipotenusa(a = 5,  b = 5)\n\nEncontrar la Hipotenusa de:\nh=?, a = 10, b = 6\nh=?, a = 5, b = 4\nh=?, a = 3, b = 4"
  },
  {
    "objectID": "loops_R.html",
    "href": "loops_R.html",
    "title": "7  Estructuras de Control",
    "section": "",
    "text": "Las iteraciones (loops) son de gran utilidad cuando necesitamos hacer la misma tarea con multiples entradas; repetir la misma operación en diferentes columnas o en diferentes conjuntos de datos.\nBeneficios\n\nEs más fácil ver el objetivo de tu código; lo diferente llama más atención a la vista que aquello que permanece igual.\nEs más sencillo responder a cambios en los requerimientos. A medida que tus necesidades cambian, solo necesitarás realizar cambios en un lugar, en vez de recordar cambiar en cada lugar donde copiaste y pegaste el código.\nEs probable que tengas menos errores porque cada línea de código es utilizada en más lugares.\n\nLa sintaxis básica es:\nAl escribir un bucle for la parte que corresponde al elemento la podemos llamar como nosotros deseemos, pero la parte que corresponde al objeto debe ser el nombre de un objeto existente.\n\nfor(elemento in objeto) {\n  operacion_con_elemento\n}\n\nEjemplo simple: print una secuencia\n\nfor (i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nEjemplo 2: Guardando los resultados en un vector\n\ndado <- 1:6\nmi_vector <- NULL\nfor(cara in dado) {\n  mi_vector[cara] <- cara ^ 2\n}\nmi_vector\n\n[1]  1  4  9 16 25 36\n\n\nEjemplo 3: Loops con vectores\n\nalumnos <- c(\"Carmen\", \"Adriana\", \"Marco\", \"Fabi\", \"Brenda\")\n\nfor(i in 1:length(alumnos)) {\n  print(paste(\"Hola,\", alumnos[i], sep = \" \"))\n}\n\n[1] \"Hola, Carmen\"\n[1] \"Hola, Adriana\"\n[1] \"Hola, Marco\"\n[1] \"Hola, Fabi\"\n[1] \"Hola, Brenda\"\n\n\nEjemplo 4: loops en Dataframes\n\ndf <- data.frame(a = rnorm(10), b = rnorm(10),\n                 c = rnorm(10), d = rnorm(10))\n\nfor(i in 1:ncol(df)){\n  promedio = mean(df[,i])\n  print(promedio)\n}\n\n[1] -0.3901721\n[1] 0.0458151\n[1] -0.2171376\n[1] 0.8233735\n\n\nOtras estucturas de control son if, else, while, break, next, que se pueden econtrar mayores referencias en los siguientes libros:\n\nhttps://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html\nhttps://es.r4ds.hadley.nz/iteración.html\nhttps://rstudio-pubs-static.s3.amazonaws.com/623888_497a5388a98545c48e9b5b6bec4056f6.html"
  },
  {
    "objectID": "tarea_1.html#antecedentes",
    "href": "tarea_1.html#antecedentes",
    "title": "Tarea 1",
    "section": "Antecedentes",
    "text": "Antecedentes\nFecha de Entrega: 21 de Abril del 2023\nFormato de Entrega: Documento de texto (word, pdf, markdown) + códigos (.R)\nIntegrantes: 2 Personas"
  },
  {
    "objectID": "tarea_1.html#enuncuciado",
    "href": "tarea_1.html#enuncuciado",
    "title": "Tarea 1",
    "section": "Enuncuciado",
    "text": "Enuncuciado\n\nCrear un raster de ncol = 500, nrow = 500, projection = crs_utm (objeto creado anteriormente), valores aleatorios y plot. (2 puntos).\n\n\n\n\n\n\n\nTip: Section 3.3\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia pero con la raiz cuadrada de los valores originales, y si existe un valor de pixel mayor a 35 debe ser cambiado por 35, finalmente plot (2 Puntos).\n\n\n\n\n\n\n\nTip: Section 3.3.2)\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia y reclasificar todos sus valores, de 0 a 500 valor 1, 501 a 1000 valor 2, 1001 a 1500 valor 3, mayor a 1500 será 4, finalmente plot (2 puntos). (Hint: )\n\n\n\n\n\n\n\nTip: Section 3.3.3"
  },
  {
    "objectID": "tarea_1.html#adicional",
    "href": "tarea_1.html#adicional",
    "title": "Tarea 1",
    "section": "Adicional",
    "text": "Adicional\nSe les recuerda seguir el manual de instalación del librería rgee que se encuentra en el siguiente anexo Chapter 8"
  },
  {
    "objectID": "tarea_1.html#referencias",
    "href": "tarea_1.html#referencias",
    "title": "Tarea 1",
    "section": "Referencias",
    "text": "Referencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "install_rgee.html#registrarse-en-gee",
    "href": "install_rgee.html#registrarse-en-gee",
    "title": "8  Instalación de Rgee",
    "section": "8.1 Registrarse en GEE",
    "text": "8.1 Registrarse en GEE\nPara acceder de los recursos de la plataforma de Google Earth Engine desde R de acuerdo al programa del curso, correspondiendo a los siguientes pasos:\n\n\nTener cuenta en google (gmail)\n\n\nDirigirse a la siguiente página web https://earthengine.google.com\n\n\n\n\n\n\n\nRegistrarse con la cuenta google, presionando botón “sing up” esquina superior derecha.\n\n\nRecibir un correo de confirmación en el gmail."
  },
  {
    "objectID": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "href": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "title": "8  Instalación de Rgee",
    "section": "8.2 Instalación de librería Rgee en R",
    "text": "8.2 Instalación de librería Rgee en R\nEl package rgee es una “librería cliente” de Earth Engine para R, que permite a los usuarios aprovechar las ventajas que presenta el ecosistema espacial de R dentro de Google Earth Engine y viceversa.\nTodas las clases, módulos y funciones de la API de Python de Earth Engine están disponibles en R gracias a la librería reticulate; finalmente rgee adiciona nuevos features como el diseño del imput y output de datos, la visualización en mapas interactivos, la facil extracción de series de tiempo, el manejo y la visualización de metadato\n\n\n\nOpción 1: Diretamente desde CRAN\n\ninstall.packages(\"rgee\")\n\n\nOpción de Desarrollo: Desde la Versión de Desarrollo alojada en Github\n\n# install.packages(\"remotes\")\nremotes::install_github(\"r-spatial/rgee\", force = TRUE)\n\nInstalar Dependencias\n\nlibrary(rgee)\nee_install() # Consulta sobre crear ambiente virtual python \"Yes\"\n# Ahora de debe reiniciar Rstudio\n\nRevisión de Instalación correcta\n\n# Iniciar Servicio\nlibrary(rgee)\nee_Initialize()\n\n# Selección de producto satelital (Modelo Digital de Elevación)\nsrtm <- ee$Image(\"USGS/SRTMGL1_003\")\n\n# parámetros de visualización\nviz <- list(\n  max = 4000,\n  min = 0,\n  palette = c(\"#000000\",\"#5AAD5A\",\"#A9AD84\",\"#FFFFFF\")\n)\n\n# Visualización map dinámico\nm <- Map$addLayer(\n  eeObject = srtm,\n  visParams =  viz,\n  name = 'SRTM'\n)\nm"
  },
  {
    "objectID": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "href": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "title": "8  Instalación de Rgee",
    "section": "8.3 Usuarios con experiencie en enviroments virtuales",
    "text": "8.3 Usuarios con experiencie en enviroments virtuales\n\n#Use ee_install_set_pyenv (Recommended for users with experience with Python environments)\n\nrgee::ee_install_set_pyenv(\n  py_path = \"/home/csaybar/.virtualenvs/rgee/bin/python\", # Change it for your own Python PATH\n  py_env = \"rgee\" # Change it for your own Python ENV\n)"
  },
  {
    "objectID": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "href": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "title": "8  Instalación de Rgee",
    "section": "8.4 Otras Librerías que se deben instalar",
    "text": "8.4 Otras Librerías que se deben instalar\n\ninstall.packages(\"sf\") # Mapas dinámicos\ninstall.packages(\"mapview\") # Mapas dinámicos\ninstall.packages(\"reticulate\") # interface python\ninstall.packages(\"jsonlite\") #manipulación de datos tipo Json\ninstall.packages('tidyverse') # Para ciencia de datos\ninstall.packages('cptcity') #Para manejar paletas decolores\ninstall.packages('viridis') #Para manejar paletas decolores\ninstall.packages('ggmap') # Para manejar tipos de basemap\ninstall.packages('plot3D') #plot objetos 3d"
  },
  {
    "objectID": "install_rgee.html#referencias",
    "href": "install_rgee.html#referencias",
    "title": "8  Instalación de Rgee",
    "section": "8.5 Referencias",
    "text": "8.5 Referencias\nGoogle Earth Engine for R https://github.com/r-spatial/rgee\nEjemplos https://csaybar.github.io/rgee-examples/\nManual en Español https://barja8.github.io/Handbook_rgee/pdf/vol01.pdf\nIntroduction to rgee https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html"
  },
  {
    "objectID": "install_rgee.html#contactos",
    "href": "install_rgee.html#contactos",
    "title": "8  Instalación de Rgee",
    "section": "8.6 Contactos",
    "text": "8.6 Contactos\nDenis Berroeta G.\nInvestigador, Centro Inteligencia Territorial, Design Lab UAI\ndenis.berroeta@uai.cl\nAv. Presidente Errázuriz 3485, Las Condes\n**Felipe Matas*\nAnalista, Centro Inteligencia Territorial, Design Lab UAI\nfelipe.matas@edu.uai.cl\nAv. Presidente Errázuriz 3485, Las Condes"
  }
]