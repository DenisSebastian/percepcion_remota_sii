[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "",
    "text": "1 Introducción\nEl curso se enfoca en entregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural. Para ello se utilizará la plataforma Google Earth Engine (GEE), introduciendo el manejo básico para almacenar, visualizar y analizar imágenes satelitales."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "objetivos.html#objetivo-general",
    "href": "objetivos.html#objetivo-general",
    "title": "2  Objetivos",
    "section": "2.1 Objetivo General:",
    "text": "2.1 Objetivo General:\nEl objetivo general del curso es entregar a los participantes las herramientas de análisis cuantitativo territorial, introduciendo el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine."
  },
  {
    "objectID": "objetivos.html#objetivos-específicos",
    "href": "objetivos.html#objetivos-específicos",
    "title": "2  Objetivos",
    "section": "2.2 Objetivos Específicos",
    "text": "2.2 Objetivos Específicos\n\nEntregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural.\nCapacitar a los asistentes en el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine, para manipular, sistematizar y procesar insumos provenientes de diferentes sensores satelitales.\nEntregar a los asistentes las capacidades metodológicas base para el diseño y la construcción de un conjunto de índices espectrales e indicadores ambientales, utilizando la imaginería satelital disponible a la comunidad."
  },
  {
    "objectID": "install_rgee.html#registrarse-en-gee",
    "href": "install_rgee.html#registrarse-en-gee",
    "title": "4  Instalación de Rgee",
    "section": "4.1 Registrarse en GEE",
    "text": "4.1 Registrarse en GEE\nPara acceder de los recursos de la plataforma de Google Earth Engine desde R de acuerdo al programa del curso, correspondiendo a los siguientes pasos:\n\n\nTener cuenta en google (gmail)\n\n\nDirigirse a la siguiente página web https://earthengine.google.com\n\n\n\n\n\n\n\nRegistrarse con la cuenta google, presionando botón “sing up” esquina superior derecha.\n\n\nRecibir un correo de confirmación en el gmail."
  },
  {
    "objectID": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "href": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "title": "4  Instalación de Rgee",
    "section": "4.2 Instalación de librería Rgee en R",
    "text": "4.2 Instalación de librería Rgee en R\nEl package rgee es una “librería cliente” de Earth Engine para R, que permite a los usuarios aprovechar las ventajas que presenta el ecosistema espacial de R dentro de Google Earth Engine y viceversa.\nTodas las clases, módulos y funciones de la API de Python de Earth Engine están disponibles en R gracias a la librería reticulate; finalmente rgee adiciona nuevos features como el diseño del imput y output de datos, la visualización en mapas interactivos, la facil extracción de series de tiempo, el manejo y la visualización de metadato\n\n\n\nOpción 1: Diretamente desde CRAN\n\ninstall.packages(\"rgee\")\n\n\nOpción de Desarrollo: Desde la Versión de Desarrollo alojada en Github\n\n# install.packages(\"remotes\")\nremotes::install_github(\"r-spatial/rgee\", force = TRUE)\n\nInstalar Dependencias\n\nlibrary(rgee)\nee_install() # Consulta sobre crear ambiente virtual python \"Yes\"\n# Ahora de debe reiniciar Rstudio\n\nRevisión de Instalación correcta\n\n# Iniciar Servicio\nlibrary(rgee)\nee_Initialize()\n\n# Selección de producto satelital (Modelo Digital de Elevación)\nsrtm <- ee$Image(\"USGS/SRTMGL1_003\")\n\n# parámetros de visualización\nviz <- list(\n  max = 4000,\n  min = 0,\n  palette = c(\"#000000\",\"#5AAD5A\",\"#A9AD84\",\"#FFFFFF\")\n)\n\n# Visualización map dinámico\nm <- Map$addLayer(\n  eeObject = srtm,\n  visParams =  viz,\n  name = 'SRTM'\n)\nm"
  },
  {
    "objectID": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "href": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "title": "4  Instalación de Rgee",
    "section": "4.4 Otras Librerías que se deben instalar",
    "text": "4.4 Otras Librerías que se deben instalar\n\ninstall.packages(\"sf\") # Mapas dinámicos\ninstall.packages(\"mapview\") # Mapas dinámicos\ninstall.packages(\"reticulate\") # interface python\ninstall.packages(\"jsonlite\") #manipulación de datos tipo Json\ninstall.packages('tidyverse') # Para ciencia de datos\ninstall.packages('cptcity') #Para manejar paletas decolores\ninstall.packages('viridis') #Para manejar paletas decolores\ninstall.packages('ggmap') # Para manejar tipos de basemap\ninstall.packages('plot3D') #plot objetos 3d"
  },
  {
    "objectID": "install_rgee.html#referencias",
    "href": "install_rgee.html#referencias",
    "title": "4  Instalación de Rgee",
    "section": "4.5 Referencias",
    "text": "4.5 Referencias\nGoogle Earth Engine for R https://github.com/r-spatial/rgee\nEjemplos https://csaybar.github.io/rgee-examples/\nManual en Español https://barja8.github.io/Handbook_rgee/pdf/vol01.pdf\nIntroduction to rgee https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html"
  },
  {
    "objectID": "install_rgee.html#contactos",
    "href": "install_rgee.html#contactos",
    "title": "4  Instalación de Rgee",
    "section": "4.6 Contactos",
    "text": "4.6 Contactos\nDenis Berroeta G.\nInvestigador, Centro Inteligencia Territorial, Design Lab UAI\ndenis.berroeta@uai.cl\nAv. Presidente Errázuriz 3485, Las Condes\n**Felipe Matas*\nAnalista, Centro Inteligencia Territorial, Design Lab UAI\nfelipe.matas@edu.uai.cl\nAv. Presidente Errázuriz 3485, Las Condes"
  },
  {
    "objectID": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "href": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "title": "4  Instalación de Rgee",
    "section": "4.3 Usuarios con experiencie en enviroments virtuales",
    "text": "4.3 Usuarios con experiencie en enviroments virtuales\n\n#Use ee_install_set_pyenv (Recommended for users with experience with Python environments)\n\nrgee::ee_install_set_pyenv(\n  py_path = \"/home/csaybar/.virtualenvs/rgee/bin/python\", # Change it for your own Python PATH\n  py_env = \"rgee\" # Change it for your own Python ENV\n)"
  },
  {
    "objectID": "fundamentos_PR.html#agenda",
    "href": "fundamentos_PR.html#agenda",
    "title": "3  Percepción Remota",
    "section": "3.1 Agenda:",
    "text": "3.1 Agenda:\n\n3.1.1 Conceptos Generales\n\n3.1.1.0.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.1.1.0.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información\n\n\n\n\n\n3.1.1.0.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.1.1.0.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano\n\n\n\n\n\n\n3.1.2 Clases Matriz y Array en R\nUn raster multibanda es un array de tres dimensiones con informaciñon de referencia espacial. Por lo anterior, debemos cubrir estos tipos de estructuras de datos en R.\n\n3.1.2.0.1 Matrix\nSe crea con la función matrix\n\nmi_matriz <- matrix(ncol= 3,nrow = 3) # crear una matriz vacía\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# image(mi_matriz)\n\n\n\nvalores <- 1:9 # definir valores que contendrá mi matriz\nmi_matriz[] <- valores # asignación de valores a una matrix (forma no recomendada)\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# \n\nmi_matriz <- matrix(data = valores, ncol= 3, nrow = 3) # crear una matriz\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n\nla función matrix, tiene los siguientes agumentos:\n\ndata: The vector of values for the matrix (for example, 1:6)\nnrow: The number of rows\nncol: The number of columns (for example, 3)\nbyrow: Whether the matrix is filled column by column (FALSE, which is the default value) or row by row (TRUE)\n\nPara contruir la misma matriz, utilizaremos el parámetro nrow (número de filas)\n\nvalores <- 1:6\nvalores\n\n[1] 1 2 3 4 5 6\n\nmatrix(valores, nrow = 2) #mismo resultado\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nComo se observa nosotros asignamos los valores que contiene la matriz, y se pasan como un vector, donde la matriz será llenada de acuerdo a los argumentos que le entreguemos:\n\n#le pasamos un vector de largo 12 (12:1), pero existen solo 8 espacias para almacenar información\nvalores <- 12:1\nvalores\n\n [1] 12 11 10  9  8  7  6  5  4  3  2  1\n\nmatrix(valores, ncol = 4, nrow = 2)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12   10    8    6\n[2,]   11    9    7    5\n\n# en este caso los espciaos de almacenamiento de información es 16, mayor a los 12 que nosotros dimos\n# comienza a rellenar desde el pricnipio del vector dado (12:1)\nmatrix(valores, ncol = 4, nrow = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12    8    4   12\n[2,]   11    7    3   11\n[3,]   10    6    2   10\n[4,]    9    5    1    9\n\n\nFunciones básicas sobre las matrices (similar a Dataframe)\n\nvalores <- 7:12\nvalores\n\n[1]  7  8  9 10 11 12\n\nx <- matrix(valores, ncol = 3, byrow = TRUE)\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nnrow(x) # consultar número de filas\n\n[1] 2\n\nncol(x) # consultar número de columnas\n\n[1] 3\n\ndim(x) # consultar número de dixmensiónes\n\n[1] 2 3\n\nvector_x <- as.vector(x) # reconvertir a vector\n\nSubset sobre una Matriz\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nx[, c(1,3)] # leer todas las filas, y columnas 1 y 3\n\n     [,1] [,2]\n[1,]    7    9\n[2,]   10   12\n\nx[2, ] # revolcer fila 2 como vector \n\n[1] 10 11 12\n\nx[2, , drop = FALSE] # revolcer fila 2 como dataframe\n\n     [,1] [,2] [,3]\n[1,]   10   11   12\n\n\nTrasponer una matriz\n\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nt(mi_matriz)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nAplicar funciones con apply() sobre una matriz\n\napply(x, 2, mean) # aplicar funciones estadíusticas o propias\n\n[1]  8.5  9.5 10.5\n\n\nFunciones de alto performance (escritas en c++)\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\ncolSums(x) #suma de columas\n\n[1] 17 19 21\n\ncolMeans(x) # promesdio por columna\n\n[1]  8.5  9.5 10.5\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nrowSums(x) #Suma por fila\n\n[1] 24 33\n\nrowMeans(x) # prodmedio por fila\n\n[1]  8 11\n\n# PD: sirven tambien para dataframe y arrays\n\nEjemplo de martiz sin refencia espacial\n\n# class(volcano)\n# dim(volcano)\nimage(volcano, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\ncontour(volcano, add = TRUE)\n\n\n\n\n\n# install.packages(\"plot3D\")\nlibrary(plot3D)\n# reducir dimensionalidad\nVolcano <- volcano[seq(1, nrow(volcano), by = 3),\n                     seq(1, ncol(volcano), by = 3)]\n\npersp(Volcano, theta = 40, phi = 40, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nsubset\n\nr30 = volcano[30, ]  # Row 30\nr70 = volcano[70, ]  # Row 70\nplot(r30, type = \"l\", col = \"blue\", ylim = range(c(r30, r70)), ylab = \"Elevation (m)\")\nlines(r70, type = \"l\", col = \"red\")\n\n\n\n\n\n\n3.1.2.0.2 Arrays\n\n\n\nRepresentan estructuras de datos con dos o mas dimensiones, y se crean con la función “array”. Crearemos un objeto de 2 filas, 2 columnas y 3 dimesiones.\n\n# ?array\nvalores <- 1:24\nvalores\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ny <- array(data = valores, dim =  c(2,4,3)) # dim(n_filas, , n_col, n_dimensiones(capas)) \ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\n\nSubset un array\n\ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\ny[2,1,3] # seleccionar fila 2, columna 1, dimesión 3\n\n[1] 18\n\ny[2,1,] # seleccionar fila 2, columna 1, de todas las dimensiones\n\n[1]  2 10 18\n\n\n\n\n\n3.1.3 Estructura de Datos de Raster\nUn raster es una grill rectangular de valores numéricos referenciados en cirta extensión geográfica. Puede tener una (matriz) o multiples bandas (arrays).\nEn R para el tratamiento de objetos Raster se utiliza el package raster, de acuerdo a contenidos programadas de esta clase solo veremos las funciónes básicas, pero con ejemplos que represetna el mundo real.\nCaracterística importante del package raster que tienen la capacidad de trabjar con grandes raster (de mayor peso que la RAM de nuestros Equipos), donde automáticamente escribe el archivo temporal en el disco duro.\n\n\n\n\n\nlibrary(raster)\n\nz <- raster() # crear un raster vacio\nz\n\nclass      : RasterLayer \ndimensions : 180, 360, 64800  (nrow, ncol, ncell)\nresolution : 1, 1  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\n\n\n3.1.4 Crear Raster\nagregar argumentos\n\n?raster()\nx <- raster(ncol=36, nrow=18, # cantidad de folas y columnas\n            xmn=-1000, xmx=1000, ymn=-100, ymx=900)# extent (representación espacial)\nx\n\nclass      : RasterLayer \ndimensions : 18, 36, 648  (nrow, ncol, ncell)\nresolution : 55.55556, 55.55556  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n# plot(x)\n\nResolución espacial\n\nres(x)\n\n[1] 55.55556 55.55556\n\nres(x) <- 100\nres(x)\n\n[1] 100 100\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 20, 200  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n\nCambiar Numero de columnas (afecta la resolución)\n\nncol(x)\n\n[1] 20\n\nncol(x) <- 18\nncol(x)\n\n[1] 18\n\nres(x)\n\n[1] 111.1111 100.0000\n\n\ndefinir sistema de referencia de coordendas\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nprojection(x) <- crs_latlon\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\nPero Hasta acá nuestro objeto Raster no tiene valores\n\nhasValues(x) # consultar si raster tiene valores\n\n[1] FALSE\n\nncell(x) #cantidad de celdas\n\n[1] 180\n\nvalues(x) <- 1:ncell(x) # ncell (cantidad de celdas del raster)\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nVisualización\n\nlibrary(RColorBrewer)\n# display.brewer.all()\ncolores <- brewer.pal(n = 8, name = 'BrBG') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(c(colores))( 180 ) # 200 colores \nplot(x, col = pal_col)\n\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nmodificación de valores del Raster\n\nset.seed(42)\nvalues(x) <- runif(ncell(x))\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nFunciones\n\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1] 111.1111 100.0000\n\ndim(x)\n\n[1] 10 18  1\n\nxmax(x)\n\n[1] 1000\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n\nCambiar el maximum de la coordenada x del extent (bounding box)\n\nxmax(x) <- 0\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1]  55.55556 100.00000\n\ndim(x)\n\n[1] 10 18  1\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 55.55556, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nsi modifico ncol desaparece los valores\n\nncol(x) <- 10\nhasValues(x)\n\n[1] TRUE\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n# plot(x, col = pal_col)\n\n\n\n3.1.5 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, ! \nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\nFunciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nReclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)\n\n\n\n\n\n\n3.1.6 Crear Raster Mulitibanda\n\n\n\nPara crear una raster multibanda (RasterLayer) utilizaremos la función stack()\n\nr1 <- r2 <- r3 <- raster(nrow=10, ncol=10)\n# Assign random cell values\nvalues(r1) <- runif(ncell(r1))\nvalues(r2) <- runif(ncell(r2))\nvalues(r3) <- runif(ncell(r3))\n\ns <- stack(r1, r2, r3)\ns\n\nclass      : RasterStack \ndimensions : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)\nresolution : 36, 18  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :      layer.1,      layer.2,      layer.3 \nmin values : 0.0023781068, 0.0014338985, 0.0004050434 \nmax values :    0.9907958,    0.9802787,    0.9930453 \n\nnlayers(s)\n\n[1] 3\n\n\n\nb1 <- brick(r1, r2, r3)\n\nLeer un raster de ejemplo\n\nfilename <- system.file(\"external/test.grd\", package=\"raster\")\nfilename\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/raster/external/test.grd\"\n\nr_test <- raster(filename)\n# filename(r)\nhasValues(r_test)\n\n[1] TRUE\n\nplot(r_test, main='RasterLayer from file', col = pal_col)\n\n\n\n\n\nr1 <- r_test\nr2  <- calc(r_test, fun=function(x){ x[x < 500] <- NA; return(x)})\n\nr3 <- reclassify(x = r_test,\n                          rcl = c(0,300,1, \n                                  300,500,2, \n                                  500,1000,3,\n                                  1000, 2000, 4))\n\nbrick_raster <- brick(r1, r2, r3)\n\nVisualización dinámica\n\nlibrary(mapview)\npal = mapviewPalette(\"mapviewTopoColors\")\nm <- mapview(brick_raster, alpha = 0.5)\nm@map\n\n\n\n\n\n\n\n3.1.7 Guardar Raster\n\n# dir.create(path = \"data/raster\")\nwriteRaster(r_test, \"data/r_test1.tif\")"
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-generales",
    "href": "fundamentos_PR.html#conceptos-generales",
    "title": "3  S1: Percepción Remota",
    "section": "3.1 Conceptos Generales",
    "text": "3.1 Conceptos Generales\n\n3.1.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.1.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información\n\n\n\n\n\n3.1.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.1.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano"
  },
  {
    "objectID": "fundamentos_PR.html#clases-matriz-y-array-en-r",
    "href": "fundamentos_PR.html#clases-matriz-y-array-en-r",
    "title": "3  S1: Percepción Remota",
    "section": "3.4 Clases Matriz y Array en R",
    "text": "3.4 Clases Matriz y Array en R\nUn raster multibanda es un array de tres dimensiones con información de referencia espacial. Por lo anterior, debemos cubrir estos tipos de estructuras de datos en R.\n\n3.4.1 Matrix\nSe crea con la función matrix\n\nmi_matriz <- matrix(ncol= 3,nrow = 3) # crear una matriz vacía\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# image(mi_matriz)\n\n\n\nvalores <- 1:9 # definir valores que contendrá mi matriz\nmi_matriz[] <- valores # asignación de valores a una matrix (forma no recomendada)\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# \n\nmi_matriz <- matrix(data = valores, ncol= 3, nrow = 3) # crear una matriz\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n\nla función matrix, tiene los siguientes argumentos:\n\ndata: The vector of values for the matrix (for example, 1:6)\nnrow: The number of rows\nncol: The number of columns (for example, 3)\nbyrow: Whether the matrix is filled column by column (FALSE, which is the default value) or row by row (TRUE)\n\nPara construir la misma matriz, utilizaremos el parámetro nrow (número de filas)\n\nvalores <- 1:6\nvalores\n\n[1] 1 2 3 4 5 6\n\nmatrix(valores, nrow = 2) #mismo resultado\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nComo se observa nosotros asignamos los valores que contiene la matriz, y se pasan como un vector, donde la matriz será llenada de acuerdo a los argumentos que le entreguemos:\n\n#le pasamos un vector de largo 12 (12:1), pero existen solo 8 espacias para almacenar información\nvalores <- 12:1\nvalores\n\n [1] 12 11 10  9  8  7  6  5  4  3  2  1\n\nmatrix(valores, ncol = 4, nrow = 2)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12   10    8    6\n[2,]   11    9    7    5\n\n# en este caso los espacios de almacenamiento de información es 16, mayor a los 12 que nosotros dimos\n# comienza a rellenar desde el principio del vector dado (12:1)\nmatrix(valores, ncol = 4, nrow = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12    8    4   12\n[2,]   11    7    3   11\n[3,]   10    6    2   10\n[4,]    9    5    1    9\n\n\nFunciones básicas sobre las matrices (similar a Dataframe)\n\nvalores <- 7:12\nvalores\n\n[1]  7  8  9 10 11 12\n\nx <- matrix(valores, ncol = 3, byrow = TRUE)\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nnrow(x) # consultar número de filas\n\n[1] 2\n\nncol(x) # consultar número de columnas\n\n[1] 3\n\ndim(x) # consultar número de dimensiones\n\n[1] 2 3\n\nvector_x <- as.vector(x) # reconvertir a vector\n\nSubset sobre una Matriz\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nx[, c(1,3)] # leer todas las filas, y columnas 1 y 3\n\n     [,1] [,2]\n[1,]    7    9\n[2,]   10   12\n\nx[2, ] # devolver fila 2 como vector \n\n[1] 10 11 12\n\nx[2, , drop = FALSE] # devolver fila 2 como dataframe\n\n     [,1] [,2] [,3]\n[1,]   10   11   12\n\n\nTrasponer una matriz\n\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nt(mi_matriz)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nAplicar funciones con apply() sobre una matriz\n\napply(x, 2, mean) # aplicar funciones estadísticas o propias\n\n[1]  8.5  9.5 10.5\n\n\nFunciones de alto performance (escritas en c++)\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\ncolSums(x) #suma de columnas\n\n[1] 17 19 21\n\ncolMeans(x) # promedio por columna\n\n[1]  8.5  9.5 10.5\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nrowSums(x) #Suma por fila\n\n[1] 24 33\n\nrowMeans(x) # promedio por fila\n\n[1]  8 11\n\n# PD: sirven también para dataframe y arrays\n\nEjemplo de martiz sin referencia espacial\n\n# class(volcano)\n# dim(volcano)\nimage(volcano, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\ncontour(volcano, add = TRUE)\n\n\n\n\n\n# install.packages(\"plot3D\")\nlibrary(plot3D)\n# reducir dimensionalidad\nVolcano <- volcano[seq(1, nrow(volcano), by = 3),\n                     seq(1, ncol(volcano), by = 3)]\n\npersp(Volcano, theta = 40, phi = 40, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nsubset\n\nr30 = volcano[30, ]  # Row 30\nr70 = volcano[70, ]  # Row 70\nplot(r30, type = \"l\", col = \"blue\", ylim = range(c(r30, r70)), ylab = \"Elevation (m)\")\nlines(r70, type = \"l\", col = \"red\")\n\n\n\n\n\n\n3.4.2 Arrays\n\n\n\nRepresentan estructuras de datos con dos o mas dimensiones, y se crean con la función “array”. Crearemos un objeto de 2 filas, 2 columnas y 3 dimensiones.\n\n# ?array\nvalores <- 1:24\nvalores\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ny <- array(data = valores, dim =  c(2,4,3)) # dim(n_filas, , n_col, n_dimensiones(capas)) \ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\n\nSubset un array\n\ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\ny[2,1,3] # seleccionar fila 2, columna 1, dimensión 3\n\n[1] 18\n\ny[2,1,] # seleccionar fila 2, columna 1, de todas las dimensiones\n\n[1]  2 10 18"
  },
  {
    "objectID": "fundamentos_PR.html#estructura-de-datos-de-raster",
    "href": "fundamentos_PR.html#estructura-de-datos-de-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.5 Estructura de Datos de Raster",
    "text": "3.5 Estructura de Datos de Raster\nUn raster es una grilla rectangular de valores numéricos referenciados en cierta extensión geográfica. Puede tener una (matriz) o múltiples bandas (arrays).\nEn R para el tratamiento de objetos Raster se utiliza el package raster, de acuerdo a contenidos programadas de esta clase solo veremos las funciones básicas, pero con ejemplos que representa el mundo real.\nCaracterística importante del package raster que tienen la capacidad de trabajar con grandes raster (de mayor peso que la RAM de nuestros Equipos), donde automáticamente escribe el archivo temporal en el disco duro.\n\n\n\n\n\nlibrary(raster)\n\nz <- raster() # crear un raster vacio\nz\n\nclass      : RasterLayer \ndimensions : 180, 360, 64800  (nrow, ncol, ncell)\nresolution : 1, 1  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs"
  },
  {
    "objectID": "fundamentos_PR.html#crear-raster",
    "href": "fundamentos_PR.html#crear-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.4 Crear Raster",
    "text": "3.4 Crear Raster\nagregar argumentos\n\n?raster()\nx <- raster(ncol=36, nrow=18, # cantidad de folas y columnas\n            xmn=-1000, xmx=1000, ymn=-100, ymx=900)# extent (representación espacial)\nx\n\nclass      : RasterLayer \ndimensions : 18, 36, 648  (nrow, ncol, ncell)\nresolution : 55.55556, 55.55556  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n# plot(x)\n\nResolución espacial\n\nres(x)\n\n[1] 55.55556 55.55556\n\nres(x) <- 100\nres(x)\n\n[1] 100 100\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 20, 200  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n\nCambiar Numero de columnas (afecta la resolución)\n\nncol(x)\n\n[1] 20\n\nncol(x) <- 18\nncol(x)\n\n[1] 18\n\nres(x)\n\n[1] 111.1111 100.0000\n\n\ndefinir sistema de referencia de coordendas\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nprojection(x) <- crs_latlon\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\nPero Hasta acá nuestro objeto Raster no tiene valores\n\nhasValues(x) # consultar si raster tiene valores\n\n[1] FALSE\n\nncell(x) #cantidad de celdas\n\n[1] 180\n\nvalues(x) <- 1:ncell(x) # ncell (cantidad de celdas del raster)\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nVisualización\n\nlibrary(RColorBrewer)\n# display.brewer.all()\ncolores <- brewer.pal(n = 8, name = 'BrBG') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(c(colores))( 180 ) # 200 colores \nplot(x, col = pal_col)\n\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nmodificación de valores del Raster\n\nset.seed(42)\nvalues(x) <- runif(ncell(x))\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nFunciones\n\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1] 111.1111 100.0000\n\ndim(x)\n\n[1] 10 18  1\n\nxmax(x)\n\n[1] 1000\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n\nCambiar el maximum de la coordenada x del extent (bounding box)\n\nxmax(x) <- 0\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1]  55.55556 100.00000\n\ndim(x)\n\n[1] 10 18  1\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 55.55556, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nsi modifico ncol desaparece los valores\n\nncol(x) <- 10\nhasValues(x)\n\n[1] TRUE\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n# plot(x, col = pal_col)"
  },
  {
    "objectID": "fundamentos_PR.html#operaciones-básicas-sobre-un-raster",
    "href": "fundamentos_PR.html#operaciones-básicas-sobre-un-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.5 Operaciones básicas sobre un Raster",
    "text": "3.5 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, ! \nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\nFunciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nReclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)"
  },
  {
    "objectID": "fundamentos_PR.html#crear-raster-mulitibanda",
    "href": "fundamentos_PR.html#crear-raster-mulitibanda",
    "title": "3  S1: Percepción Remota",
    "section": "3.5 Crear Raster Mulitibanda",
    "text": "3.5 Crear Raster Mulitibanda\n\n\n\nPara crear una raster multibanda (RasterLayer) utilizaremos la función stack()\n\nr1 <- r2 <- r3 <- raster(nrow=10, ncol=10)\n# Assign random cell values\nvalues(r1) <- runif(ncell(r1))\nvalues(r2) <- runif(ncell(r2))\nvalues(r3) <- runif(ncell(r3))\n\ns <- stack(r1, r2, r3)\ns\n\nclass      : RasterStack \ndimensions : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)\nresolution : 36, 18  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :      layer.1,      layer.2,      layer.3 \nmin values : 0.0023781068, 0.0014338985, 0.0004050434 \nmax values :    0.9907958,    0.9802787,    0.9930453 \n\nnlayers(s)\n\n[1] 3\n\n\n\nb1 <- brick(r1, r2, r3)\n\nLeer un raster de ejemplo\n\nfilename <- system.file(\"external/test.grd\", package=\"raster\")\nfilename\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/raster/external/test.grd\"\n\nr_test <- raster(filename)\n# filename(r)\nhasValues(r_test)\n\n[1] TRUE\n\nplot(r_test, main='RasterLayer from file', col = pal_col)\n\n\n\n\n\nr1 <- r_test\nr2  <- calc(r_test, fun=function(x){ x[x < 500] <- NA; return(x)})\n\nr3 <- reclassify(x = r_test,\n                          rcl = c(0,300,1, \n                                  300,500,2, \n                                  500,1000,3,\n                                  1000, 2000, 4))\n\nbrick_raster <- brick(r1, r2, r3)\n\nVisualización dinámica\n\nlibrary(mapview)\npal = mapviewPalette(\"mapviewTopoColors\")\nm <- mapview(brick_raster, alpha = 0.5)\nm@map"
  },
  {
    "objectID": "fundamentos_PR.html#guardar-raster",
    "href": "fundamentos_PR.html#guardar-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.4 Guardar Raster",
    "text": "3.4 Guardar Raster\n\n# dir.create(path = \"data/raster\")\nwriteRaster(r_test, \"data/r_test1.tif\")"
  },
  {
    "objectID": "tarea_1.html",
    "href": "tarea_1.html",
    "title": "Tarea 1",
    "section": "",
    "text": "recordar Registro en GEE\nSing Up en https://earthengine.google.com, se debe contar con cuenta gmail solamente.\n\n\nTarea 1:\n\nEnuncuciado:\n\nCrear un raster de ncol = 500, nrow = 500, projection = crs_utm (objeto creado anteriormente), valores aleatorios y plot. (1 punto)\nDesde el raster “r_test”, crear una copia pero con la raiz cuadrada de los valores originales, y si existe un valor de pixel mayor a 35 debe ser cambiado por 35, finalmente plot (2 Puntos)\nDesde el raster “r_test”, crear una copia y reclasificar todos sus valores, de 0 a 500 valor 1, 501 a 1000 valor 2, 1001 a 1500 valor 3, mayor a 1500 será 4, finalmente plot (2 puntos)\nSeguir el manual de instalación de la librería Rgee (adjunto en material complementario), de acuerdo a la arquitectura de su equipo computacional. Finalmente visualizar mapa dinámico de cualquier producto satelital (1 Punto). Se Recomienda revisar esta página web https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html o directamente utilizar el siguiente código:\n\n\n# Iniciar Servicio\nlibrary(rgee)\nee_Initialize()\n\n# Selección de producto satelital (Modelo Digital de Elevación)\nsrtm <- ee$Image(\"USGS/SRTMGL1_003\")\n\n# parámetros de visualización\nviz <- list(\n  max = 4000,\n  min = 0,\n  palette = c(\"#000000\",\"#5AAD5A\",\"#A9AD84\",\"#FFFFFF\")\n)\n\n# Visualización map dinámico\nm <- Map$addLayer(\n  eeObject = srtm,\n  visParams =  viz,\n  name = 'SRTM',\n)\nm@map\n\nFormato: RMarkdown + html. No obstante, se aceptará el Código el Archivo .R (por ser primera entrega)\n\n\n\n\nReferencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "tarea_1.html#enuncuciado",
    "href": "tarea_1.html#enuncuciado",
    "title": "Tarea 1",
    "section": "Enuncuciado",
    "text": "Enuncuciado\n\nCrear un raster de ncol = 500, nrow = 500, projection = crs_utm (objeto creado anteriormente), valores aleatorios y plot. (2 puntos).\n\n\n\n\n\n\n\nTip: Section 3.5\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia pero con la raiz cuadrada de los valores originales, y si existe un valor de pixel mayor a 35 debe ser cambiado por 35, finalmente plot (2 Puntos).\n\n\n\n\n\n\n\nTip: Section 3.6.1)\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia y reclasificar todos sus valores, de 0 a 500 valor 1, 501 a 1000 valor 2, 1001 a 1500 valor 3, mayor a 1500 será 4, finalmente plot (2 puntos). (Hint: )\n\n\n\n\n\n\n\nTip: Section 3.6.2"
  },
  {
    "objectID": "tarea_1.html#formato",
    "href": "tarea_1.html#formato",
    "title": "Tarea 1",
    "section": "Formato",
    "text": "Formato\n\nDocumento de texto (word, pdf, markdown) + códigos"
  },
  {
    "objectID": "tarea_1.html#fechas",
    "href": "tarea_1.html#fechas",
    "title": "Tarea 1",
    "section": "Fechas",
    "text": "Fechas\n\n\nReferencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "tarea_1.html#adicional",
    "href": "tarea_1.html#adicional",
    "title": "Tarea 1",
    "section": "Adicional",
    "text": "Adicional\nSe les recuerda seguir el manual de instalación del librería rgee que se encuentra en el siguiente anexo Chapter 4"
  },
  {
    "objectID": "tarea_1.html#referencias",
    "href": "tarea_1.html#referencias",
    "title": "Tarea 1",
    "section": "Referencias",
    "text": "Referencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "fundamentos_PR.html#sec-crearRaster",
    "href": "fundamentos_PR.html#sec-crearRaster",
    "title": "3  S1: Percepción Remota",
    "section": "3.3 Crear Raster",
    "text": "3.3 Crear Raster\nagregar argumentos\n\n?raster()\nx <- raster(ncol=36, nrow=18, # cantidad de filas y columnas\n            xmn=-1000, xmx=1000, ymn=-100, ymx=900)# extent (representación espacial)\nx\n\nclass      : RasterLayer \ndimensions : 18, 36, 648  (nrow, ncol, ncell)\nresolution : 55.55556, 55.55556  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n# plot(x)\n\nResolución espacial\n\nres(x)\n\n[1] 55.55556 55.55556\n\nres(x) <- 100\nres(x)\n\n[1] 100 100\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 20, 200  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n\nCambiar Numero de columnas (afecta la resolución)\n\nncol(x)\n\n[1] 20\n\nncol(x) <- 18\nncol(x)\n\n[1] 18\n\nres(x)\n\n[1] 111.1111 100.0000\n\n\ndefinir sistema de referencia de coordenadas\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nprojection(x) <- crs_latlon\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\nPero Hasta acá nuestro objeto Raster no tiene valores\n\nhasValues(x) # consultar si raster tiene valores\n\n[1] FALSE\n\nncell(x) #cantidad de celdas\n\n[1] 180\n\nvalues(x) <- 1:ncell(x) # ncell (cantidad de celdas del raster)\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nVisualización\n\nlibrary(RColorBrewer)\n# display.brewer.all()\ncolores <- brewer.pal(n = 8, name = 'BrBG') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(c(colores))( 180 ) # 200 colores \nplot(x, col = pal_col)\n\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nmodificación de valores del Raster\n\nset.seed(42)\nvalues(x) <- runif(ncell(x))\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nFunciones\n\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1] 111.1111 100.0000\n\ndim(x)\n\n[1] 10 18  1\n\nxmax(x)\n\n[1] 1000\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n\nCambiar el maximum de la coordenada x del extent (bounding box)\n\nxmax(x) <- 0\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1]  55.55556 100.00000\n\ndim(x)\n\n[1] 10 18  1\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 55.55556, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nsi modifico ncol desaparece los valores\n\nncol(x) <- 10\nhasValues(x)\n\n[1] TRUE\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n# plot(x, col = pal_col)\n\n\n3.3.1 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, !\nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\n\n\n3.3.2 Funciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\n\n\n3.3.3 Reclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)\n\n\n\n\n\n\n3.3.4 Crear Raster Mulitibanda\n\n\n\nPara crear una raster multibanda (RasterLayer) utilizaremos la función stack()\n\nr1 <- r2 <- r3 <- raster(nrow=10, ncol=10)\n# Assign random cell values\nvalues(r1) <- runif(ncell(r1))\nvalues(r2) <- runif(ncell(r2))\nvalues(r3) <- runif(ncell(r3))\n\ns <- stack(r1, r2, r3)\ns\n\nclass      : RasterStack \ndimensions : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)\nresolution : 36, 18  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :      layer.1,      layer.2,      layer.3 \nmin values : 0.0023781068, 0.0014338985, 0.0004050434 \nmax values :    0.9907958,    0.9802787,    0.9930453 \n\nnlayers(s)\n\n[1] 3\n\n\n\nb1 <- brick(r1, r2, r3)\n\nLeer un raster de ejemplo\n\nfilename <- system.file(\"external/test.grd\", package=\"raster\")\nfilename\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/raster/external/test.grd\"\n\nr_test <- raster(filename)\n# filename(r)\nhasValues(r_test)\n\n[1] TRUE\n\nplot(r_test, main='RasterLayer from file', col = pal_col)\n\n\n\n\n\nr1 <- r_test\nr2  <- calc(r_test, fun=function(x){ x[x < 500] <- NA; return(x)})\n\nr3 <- reclassify(x = r_test,\n                          rcl = c(0,300,1, \n                                  300,500,2, \n                                  500,1000,3,\n                                  1000, 2000, 4))\n\nbrick_raster <- brick(r1, r2, r3)\n\nVisualización dinámica\n\nlibrary(mapview)\npal = mapviewPalette(\"mapviewTopoColors\")\nm <- mapview(brick_raster, alpha = 0.5)\nm@map"
  },
  {
    "objectID": "fundamentos_PR.html#sec-operRaster",
    "href": "fundamentos_PR.html#sec-operRaster",
    "title": "3  S1: Percepción Remota",
    "section": "3.4 Operaciones básicas sobre un Raster",
    "text": "3.4 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, !\nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\n\n3.4.1 Funciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\n\n\n3.4.2 Reclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)"
  },
  {
    "objectID": "tarea_1.html#antecedentes",
    "href": "tarea_1.html#antecedentes",
    "title": "Tarea 1",
    "section": "Antecedentes",
    "text": "Antecedentes\nFecha de Entrega: 21 de Abril del 2023\nFormato de Entrega: Documento de texto (word, pdf, markdown) + códigos (.R)\nIntegrantes: 2 Personas"
  },
  {
    "objectID": "index.html#programa",
    "href": "index.html#programa",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "1.1 Programa",
    "text": "1.1 Programa"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "1.2 Docentes",
    "text": "1.2 Docentes\n\nProfesor:\n\nDenis Berroeta González:\n\nCoordinador de Investigación Centro de Inteligencia Territorial (CIT).\nemail: denis.berroeta@uai.cl]\n\n\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República.\n\n\nAyudante:"
  },
  {
    "objectID": "index.html#profesor",
    "href": "index.html#profesor",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Profesor",
    "text": "Profesor\n\nDenis Berroeta González:\n\nCoordinador de Investigación en el Centro de Inteligencia Territorial (CIT).\nemail: denis.berroeta@uai.cl]\n\n\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República."
  },
  {
    "objectID": "index.html#ayudante",
    "href": "index.html#ayudante",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Ayudante",
    "text": "Ayudante\n\nFelipe Mata:\n\nAnalista de investigación y desarrollo en el Centro de Inteligencia Territorial (CIT).\nemail: felipe.matas@edu.uai.cl\n\n\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  },
  {
    "objectID": "index.html#ayudante-felipe-mata",
    "href": "index.html#ayudante-felipe-mata",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Ayudante: Felipe Mata",
    "text": "Ayudante: Felipe Mata\nAnalista de investigación y desarrollo en el Centro de Inteligencia Territorial (CIT).\nemail: felipe.matas@edu.uai.cl\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  },
  {
    "objectID": "index.html#profesor-denis-berroeta-gonzález",
    "href": "index.html#profesor-denis-berroeta-gonzález",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Profesor: Denis Berroeta González",
    "text": "Profesor: Denis Berroeta González\nCoordinador de Investigación en el Centro de Inteligencia Territorial (CIT).\nemail: denis.berroeta@uai.cl\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República."
  },
  {
    "objectID": "index.html#ayudante-felipe-matas-vicent",
    "href": "index.html#ayudante-felipe-matas-vicent",
    "title": "Curso: Geoanálisis de Imágenes Satelitales para SII",
    "section": "Ayudante: Felipe Matas Vicent",
    "text": "Ayudante: Felipe Matas Vicent\nAnalista de investigación y desarrollo en el Centro de Inteligencia Territorial (CIT).\nemail: felipe.matas@edu.uai.cl\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-sobre-raster",
    "href": "fundamentos_PR.html#conceptos-sobre-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 Conceptos sobre Raster",
    "text": "3.2 Conceptos sobre Raster\n\n3.2.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.2.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información\n\n\n\n\n\n3.2.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.2.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano"
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-teóricos",
    "href": "fundamentos_PR.html#conceptos-teóricos",
    "title": "3  S1: Percepción Remota",
    "section": "3.1 Conceptos Teóricos",
    "text": "3.1 Conceptos Teóricos\n\n3.1.1 Definición de Percepción Remota\nPercepción Remota o en una disciplina científica que entrega un amplio conjunto de conocimientos y tecnologías utilizadas para observación, análisis, la interpretación de fenómenos en el territorio.\nLa percepción remota nos permite efectuar observaciones y mediciones de la superficie terrestre mediante dispositivos remotos instalados sobre plataformas como satélites, aviones y actualmente hasta en drones. \nLos sensores instalados en estas plataformas miden una gran variedad de datos como radiaciones electromagnéticas, espectro electromagnético, perturbaciones atmosféricas, firmas espectrales y captura de imágenes, entre otros.\n\n\n\n\n\n\n\n3.1.2 Aplicaciones de la PR\nMonitoreo Ambiental:\n\nBosque Nativo: Superficie anual, Vigor vegetacional Desforestación\nContaminación de Recursos Naturales: Borde Costero, red clorhídrica, cuerpos de agua, suelos, aire.\nGlaciares: Superficie de cuerpos glaciares\nHumedales Alto Andino: Superficie anual vegetada e inundada en el humedal\n\nMonitoreo Urbano:\n\nCrecimiento urbano: Superficie urbana cambios en la ciudades y planificación\nCrecimiento rural: Superficie urbana cambios en la ruralidad\nCrecimiento asentamientos irregulares: Crecimiento de las asentamientos informales\n\nDesastres Naturales:\n\nIncendios Forestales: Estimación de superficie afectada\nTerremotos y Tsunamis: Estimación de daños gestión de riesgos\nDeslizamientos de Tierra: Estimación de superficie afectada\nAluviones: Estimación de superficie afectada\nEmergencias Volcánicas: Estimación de superficie afectada\n\nIndustrias:\n\nForestal: Estimación de superficie afectada\nMinería: Estimación de superficie afectada\nAgrícola: Estimación de superficie afectada\n\n\n\n\n\n\n\n\n3.1.3 ¿Qué es la Percepción Remota?\nLa medición de una cantidad asociada con un objeto por un aparato no en contacto directo con el objeto.\nAparatos: Antena, vehículo aéreo, satélites.\n\n\n\n\n\n¿Qué se mide?\nLos satélites llevan instrumentos o sensores que miden la radiación electromagnética: proveniente del sistema tierra - atmósfera. La intensidad de la radiación reflejada y emitida al espacio es influenciada por las condiciones en la superficie y la atmósfera.\n\n\n\n\n\n\n\n3.1.4 Radiación Electromagnética\nEl principio básico se basa en que todos los cuerpos emiten radiación electromagnética, el tipo y la cantidad depende principalmente de la temperatura del cuerpo.\nEl principal emisor de radiación es el Sol, cuyo reflejo en la superficie y atmósfera terrestre nos permite ver y analizar los objetos a nuestro alrededor.\n\n\n\nLa vegetación verde, absorbe las ondas azules (B) y rojas (R) y refleja las verdes (G) e infrarrojas (IR)\n\n\n\n\n3.1.5 Espectro Electromanético\nEs un conjunto de frecuencias o longitudes de onda en los que se organiza la radiación electromagnética. Abarca las radiaciones entre los rayos gamma y las ondas de radio.\n\n\n\n\n\n\n\n3.1.6 Firmas Espectrales\nCada tipo de superficie tiene su propia firma espectral. Las imágenes percibidas remotamente (satélites) adquieren información en diferentes longitudes de onda, representando diferentes partes del Espectro Electromagnético.\n\n\n\nEjemplo: Vegetación Sana, tiene peaks en Banda Verde (550 nm) y comienzo del Banda Infrarroja (750 nm)"
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "href": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 Conceptos Prácticos sobre Raster",
    "text": "3.2 Conceptos Prácticos sobre Raster\nPara poder trabajar con información satelital, primero hay que conocer la estructura básica de una imagen y como la entiende en términos de estructura una herramienta informática como los equipos computacionales o servidores cloud para poder realizar todos los análisis que se pretenden.\nLa estructura matemática mínima de una imagen es un matriz, para operar operar sobre ella la usaremos a un nivel más complejo llamado raster.\n\n3.2.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.2.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información\n\n\n\n\n\n3.2.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.2.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano\n\n\n\n\n\n3.2.5 Clases Matriz y Array en R\nUn raster multibanda es un array de tres dimensiones con información de referencia espacial. Por lo anterior, debemos cubrir estos tipos de estructuras de datos en R.\n\n\n3.2.6 Matrix\nSe crea con la función matrix\n\nmi_matriz <- matrix(ncol= 3,nrow = 3) # crear una matriz vacía\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# image(mi_matriz)\n\n\n\nvalores <- 1:9 # definir valores que contendrá mi matriz\nmi_matriz[] <- valores # asignación de valores a una matrix (forma no recomendada)\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n# \n\nmi_matriz <- matrix(data = valores, ncol= 3, nrow = 3) # crear una matriz\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# plot(raster(mi_matriz), col = heat.colors(9, rev = T))\n\nla función matrix, tiene los siguientes argumentos:\n\ndata: The vector of values for the matrix (for example, 1:6)\nnrow: The number of rows\nncol: The number of columns (for example, 3)\nbyrow: Whether the matrix is filled column by column (FALSE, which is the default value) or row by row (TRUE)\n\nPara construir la misma matriz, utilizaremos el parámetro nrow (número de filas)\n\nvalores <- 1:6\nvalores\n\n[1] 1 2 3 4 5 6\n\nmatrix(valores, nrow = 2) #mismo resultado\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nComo se observa nosotros asignamos los valores que contiene la matriz, y se pasan como un vector, donde la matriz será llenada de acuerdo a los argumentos que le entreguemos:\n\n#le pasamos un vector de largo 12 (12:1), pero existen solo 8 espacias para almacenar información\nvalores <- 12:1\nvalores\n\n [1] 12 11 10  9  8  7  6  5  4  3  2  1\n\nmatrix(valores, ncol = 4, nrow = 2)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12   10    8    6\n[2,]   11    9    7    5\n\n# en este caso los espacios de almacenamiento de información es 16, mayor a los 12 que nosotros dimos\n# comienza a rellenar desde el principio del vector dado (12:1)\nmatrix(valores, ncol = 4, nrow = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]   12    8    4   12\n[2,]   11    7    3   11\n[3,]   10    6    2   10\n[4,]    9    5    1    9\n\n\nFunciones básicas sobre las matrices (similar a Dataframe)\n\nvalores <- 7:12\nvalores\n\n[1]  7  8  9 10 11 12\n\nx <- matrix(valores, ncol = 3, byrow = TRUE)\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nnrow(x) # consultar número de filas\n\n[1] 2\n\nncol(x) # consultar número de columnas\n\n[1] 3\n\ndim(x) # consultar número de dimensiones\n\n[1] 2 3\n\nvector_x <- as.vector(x) # reconvertir a vector\n\nSubset sobre una Matriz\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nx[, c(1,3)] # leer todas las filas, y columnas 1 y 3\n\n     [,1] [,2]\n[1,]    7    9\n[2,]   10   12\n\nx[2, ] # devolver fila 2 como vector \n\n[1] 10 11 12\n\nx[2, , drop = FALSE] # devolver fila 2 como dataframe\n\n     [,1] [,2] [,3]\n[1,]   10   11   12\n\n\nTrasponer una matriz\n\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nt(mi_matriz)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nAplicar funciones con apply() sobre una matriz\n\napply(x, 2, mean) # aplicar funciones estadísticas o propias\n\n[1]  8.5  9.5 10.5\n\n\nFunciones de alto performance (escritas en c++)\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\ncolSums(x) #suma de columnas\n\n[1] 17 19 21\n\ncolMeans(x) # promedio por columna\n\n[1]  8.5  9.5 10.5\n\nx\n\n     [,1] [,2] [,3]\n[1,]    7    8    9\n[2,]   10   11   12\n\nrowSums(x) #Suma por fila\n\n[1] 24 33\n\nrowMeans(x) # promedio por fila\n\n[1]  8 11\n\n# PD: sirven también para dataframe y arrays\n\nEjemplo de martiz sin referencia espacial\n\n# class(volcano)\n# dim(volcano)\nimage(volcano, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\ncontour(volcano, add = TRUE)\n\n\n\n\n\n# install.packages(\"plot3D\")\nlibrary(plot3D)\n# reducir dimensionalidad\nVolcano <- volcano[seq(1, nrow(volcano), by = 3),\n                     seq(1, ncol(volcano), by = 3)]\n\npersp(Volcano, theta = 40, phi = 40, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\nsubset\n\nr30 = volcano[30, ]  # Row 30\nr70 = volcano[70, ]  # Row 70\nplot(r30, type = \"l\", col = \"blue\", ylim = range(c(r30, r70)), ylab = \"Elevation (m)\")\nlines(r70, type = \"l\", col = \"red\")\n\n\n\n\n\n\n3.2.7 Arrays\n\n\n\nRepresentan estructuras de datos con dos o mas dimensiones, y se crean con la función “array”. Crearemos un objeto de 2 filas, 2 columnas y 3 dimensiones.\n\n# ?array\nvalores <- 1:24\nvalores\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ny <- array(data = valores, dim =  c(2,4,3)) # dim(n_filas, , n_col, n_dimensiones(capas)) \ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\n\nSubset un array\n\ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\ny[2,1,3] # seleccionar fila 2, columna 1, dimensión 3\n\n[1] 18\n\ny[2,1,] # seleccionar fila 2, columna 1, de todas las dimensiones\n\n[1]  2 10 18\n\n\n\n\n3.2.8 Estructura de Datos de Raster\nUn raster es una grilla rectangular de valores numéricos referenciados en cierta extensión geográfica. Puede tener una (matriz) o múltiples bandas (arrays).\nEn R para el tratamiento de objetos Raster se utiliza el package raster, de acuerdo a contenidos programadas de esta clase solo veremos las funciones básicas, pero con ejemplos que representa el mundo real.\nCaracterística importante del package raster que tienen la capacidad de trabajar con grandes raster (de mayor peso que la RAM de nuestros Equipos), donde automáticamente escribe el archivo temporal en el disco duro.\n\n\n\n\n\nlibrary(raster)\n\nz <- raster() # crear un raster vacio\nz\n\nclass      : RasterLayer \ndimensions : 180, 360, 64800  (nrow, ncol, ncell)\nresolution : 1, 1  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs"
  },
  {
    "objectID": "fundamentos_PR.html#section",
    "href": "fundamentos_PR.html#section",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 ",
    "text": "3.2"
  },
  {
    "objectID": "fundamentos_PR.html#firmas-espectrales",
    "href": "fundamentos_PR.html#firmas-espectrales",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 Firmas Espectrales",
    "text": "3.2 Firmas Espectrales\nCada tipo de superficie tiene su propia firma espectral. Las imágenes percibidas remotamente (satélites) adquieren información en diferentes longitudes de onda, representando diferentes partes del Espectro Electromagnético.\n\n\n\nEjemplo: Vegetación Sana, tiene peaks en Banda Verde (550 nm) y comienzo del Banda Infrarroja (750 nm)"
  }
]