[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "",
    "text": "1 Introducción\nEl curso se enfoca en entregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural. Para ello se utilizará la plataforma Google Earth Engine (GEE), introduciendo el manejo básico para almacenar, visualizar y analizar imágenes satelitales."
  },
  {
    "objectID": "index.html#programa",
    "href": "index.html#programa",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "1.1 Programa",
    "text": "1.1 Programa"
  },
  {
    "objectID": "index.html#profesor-denis-berroeta-gonzález",
    "href": "index.html#profesor-denis-berroeta-gonzález",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "Profesor: Denis Berroeta González",
    "text": "Profesor: Denis Berroeta González\nCoordinador de Investigación en el Centro de Inteligencia Territorial (CIT).\nemail: Denis Berroeta\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República."
  },
  {
    "objectID": "index.html#ayudante-felipe-matas-vicent",
    "href": "index.html#ayudante-felipe-matas-vicent",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "Ayudante: Felipe Matas Vicent",
    "text": "Ayudante: Felipe Matas Vicent\nAnalista de investigación y desarrollo en el Centro de Inteligencia Territorial (CIT).\nemail: felipe.matas@edu.uai.cl\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  },
  {
    "objectID": "objetivos.html#objetivo-general",
    "href": "objetivos.html#objetivo-general",
    "title": "2  Objetivos",
    "section": "2.1 Objetivo General:",
    "text": "2.1 Objetivo General:\nEl objetivo general del curso es entregar a los participantes las herramientas de análisis cuantitativo territorial, introduciendo el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine."
  },
  {
    "objectID": "objetivos.html#objetivos-específicos",
    "href": "objetivos.html#objetivos-específicos",
    "title": "2  Objetivos",
    "section": "2.2 Objetivos Específicos",
    "text": "2.2 Objetivos Específicos\n\nEntregar a los asistentes las nociones básicas de Percepción Remota aplicada en diferentes ámbitos, tales como medio ambiente, urbanismo, contaminación, recursos y capital natural.\nCapacitar a los asistentes en el manejo básico de la plataforma de almacenamiento, visualización y análisis de imágenes satelitales Google Earth Engine, para manipular, sistematizar y procesar insumos provenientes de diferentes sensores satelitales.\nEntregar a los asistentes las capacidades metodológicas base para el diseño y la construcción de un conjunto de índices espectrales e indicadores ambientales, utilizando la imaginería satelital disponible a la comunidad."
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-teóricos",
    "href": "fundamentos_PR.html#conceptos-teóricos",
    "title": "3  S1: Percepción Remota",
    "section": "3.1 Conceptos Teóricos",
    "text": "3.1 Conceptos Teóricos\n\n3.1.1 Definición de Percepción Remota\nLa Percepción Remota es una disciplina científica que, en la actualidad, se presenta como una herramienta clave para el estudio de la Tierra y su entorno. Esta disciplina proporciona un amplio conjunto de conocimientos y tecnologías utilizados para la observación, el análisis y la interpretación de fenómenos en la superficie terrestre.\nEn términos generales, la Percepción Remota nos permite llevar a cabo observaciones y mediciones mediante dispositivos remotos, como satélites, aviones y drones. Los sensores instalados en estas plataformas miden una gran variedad de datos, entre ellos radiaciones electromagnéticas, espectro electromagnético, perturbaciones atmosféricas, firmas espectrales y captura de imágenes.\nLa Percepción Remota se ha convertido en una disciplina fundamental para el estudio de la Tierra y su entorno, y su aplicación en la investigación y la gestión de recursos naturales ha demostrado ser de gran utilidad en la toma de decisiones en distintos ámbitos. En este sentido, el desarrollo de tecnologías cada vez más sofisticadas y eficientes en la captura y procesamiento de datos, así como la creciente cantidad de información disponible, hacen que la Percepción Remota siga siendo un campo en constante evolución y con un gran potencial para el futuro.\n\n\n\n\n\n\n\n3.1.2 Aplicaciones de la PR\nLa importancia de la Percepción Remota radica en su capacidad para capturar información valiosa sobre la superficie terrestre, lo que ha permitido importantes avances en áreas como la agricultura, la geología, la climatología y la gestión de recursos naturales. Por ejemplo, gracias a la Percepción Remota, hoy en día es posible monitorear la salud de los cultivos y prevenir enfermedades, identificar zonas de riesgo para la exploración de recursos minerales y petroleros, predecir desastres naturales y monitorear los efectos del cambio climático. A continuación se describen algunos ejemplos de usos de la perceción remota:\nMonitoreo Ambiental:\n\nBosque Nativo: Superficie anual, Vigor vegetacional Desforestación\nContaminación de Recursos Naturales: Borde Costero, red clorhídrica, cuerpos de agua, suelos, aire.\nGlaciares: Superficie de cuerpos glaciares\nHumedales Alto Andino: Superficie anual vegetada e inundada en el humedal\n\nMonitoreo Urbano:\n\nCrecimiento urbano: Superficie urbana cambios en la ciudades y planificación\nCrecimiento rural: Superficie urbana cambios en la ruralidad\nCrecimiento asentamientos irregulares: Crecimiento de las asentamientos informales\n\nDesastres Naturales:\n\nIncendios Forestales: Estimación de superficie afectada\nTerremotos y Tsunamis: Estimación de daños gestión de riesgos\nDeslizamientos de Tierra: Estimación de superficie afectada\nAluviones: Estimación de superficie afectada\nEmergencias Volcánicas: Estimación de superficie afectada\n\nIndustrias:\n\nForestal: Estimación de superficie afectada\nMinería: Estimación de superficie afectada\nAgrícola: Estimación de superficie afectada\n\n\n\n\n3.1.3 ¿Qué es la Percepción Remota?\nLa medición de una cantidad asociada con un objeto por un aparato no en contacto directo con el objeto.\nAparatos: Antena, vehículo aéreo, satélites.\n\n\n\n\n\n¿Qué se mide la percepción remota satelital?\nLa percepción remota satelital utiliza instrumentos y sensores para medir la radiación electromagnética proveniente del sistema tierra-atmósfera. La intensidad de la radiación reflejada y emitida al espacio está influenciada por las condiciones en la superficie y la atmósfera.\n\n\n\n\n\nLa radiación electromagnética producida por el Sol es la energía que emite en forma de ondas electromagnéticas. Esta radiación se divide en diferentes tipos según su longitud de onda, como los rayos X, los rayos gamma, la luz visible, las ondas de radio, entre otros.\nLa atmósfera terrestre juega un papel importante en la radiación electromagnética que llega a la superficie terrestre. Parte de la radiación es absorbida por la atmósfera, mientras que otra parte es reflejada y dispersada en diferentes direcciones. El efecto de la atmósfera puede modificar la intensidad de la radiación que llega a la superficie terrestre y puede afectar las mediciones realizadas por los dispositivos de percepción remota. Por esta razón, es importante tener en cuenta las condiciones atmosféricas al interpretar las mediciones de sensores remotos.\n\n\n3.1.4 Radiación Electromagnética\nEl principio básico se basa en que todos los cuerpos emiten radiación electromagnética, el tipo y la cantidad depende principalmente de la temperatura del cuerpo (Figure 3.1).\nEl principal emisor de radiación es el Sol, cuyo reflejo en la superficie y atmósfera terrestre nos permite ver y analizar los objetos a nuestro alrededor.\n\n\n\nFigure 3.1: La vegetación verde, absorbe las ondas azules (B) y rojas (R) y refleja las verdes (G) e infrarrojas (IR)\n\n\n\n\n3.1.5 Espectro Electromanético\nEl espectro electromagnético es el conjunto de todas las ondas electromagnéticas que existen, desde las ondas de radio hasta los rayos gamma (Figure 3.2). Cada tipo de onda electromagnética tiene una longitud de onda y una frecuencia específicas que determinan su ubicación en el espectro. Las ondas de radio tienen la longitud de onda más larga y la frecuencia más baja, mientras que los rayos gamma tienen la longitud de onda más corta y la frecuencia más alta.\nLa percepción remota satelital se basa en la medición de la radiación electromagnética que emiten los objetos de la superficie terrestre, y los sensores instalados en los satélites miden la radiación en diferentes longitudes de onda para obtener información sobre la composición y las características de los objetos que se están observando.\n\n\n\nFigure 3.2: Espectro Electromanético\n\n\n\n\n3.1.6 Firmas Espectrales\nUna vez que la energía electromagnética llega a la superficie terrestre, interactúa con cada tipo de material ya sea por reflexión, absorción o transmisión, de acuerdo a un patrón de respuesta espectral particular. Este comportamiento distintivo de cada tipo de material es aprovechado en procesos de clasificación de imágenes, siendo común referirse a él como “firma espectral”.\n\n\n\nEjemplo: Vegetación Sana, tiene peaks en Banda Verde (550 nm) y comienzo del Banda Infrarroja (750 nm)"
  },
  {
    "objectID": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "href": "fundamentos_PR.html#conceptos-prácticos-sobre-raster",
    "title": "3  S1: Percepción Remota",
    "section": "3.2 Conceptos Prácticos sobre Raster",
    "text": "3.2 Conceptos Prácticos sobre Raster\nLa estructura matemática mínima de una imagen es una matriz, para operar operar sobre ella la usaremos a un nivel más complejo llamado raster. En el contexto de la percepción remota satelital, las imágenes se pueden representar como una matriz de píxeles, donde cada píxel se identifica por su ubicación en la fila y columna correspondiente de la matriz. Al analizar las propiedades de los píxeles, como su valor de reflectancia o su firma espectral, se puede obtener información sobre las características de los objetos que se están observando en la imagen.\n\n3.2.1 Definición Raster\nLos objetos raster representan entidades geográficas dividiendo el espacio físico en celdas discretas cuadradas o rectangulares dispuestas en una cuadrícula. De igual forma,\n\n\n\n\n\n3.2.2 Matriz de un Raster\nUn ráster consta de una matriz de celdas (o píxeles) organizadas en filas y columnas (o una cuadrícula) en la que cada celda contiene un valor que representa información.\n\n\n\n\n\n3.2.3 Resolución Espacial\nCuanto más pequeño sea el tamaño de celda, más suave o más detallado será el ráster. Sin embargo, cuanto mayor sea el número de celdas, más tiempo tardará en procesar, aumentándose a su vez la demanda de espacio de almacenamiento.\n\n\n\n\n\n3.2.4 Referencia Espacial\nLa matriz queda representada por un Sistema de coordenadas cartesianas, en las que las filas de la matriz son paralelas al eje x y las columnas al eje y del plano cartesiano\n\n\n\n\n\n3.2.5 Clases Matriz y Array en R\nUna matriz es una estructura matemática muy común en la cual se representan datos en forma de arreglos rectangulares de números o símbolos. Las matrices se componen de filas y columnas, y cada entrada en la matriz se identifica por su posición en la fila y columna correspondiente.\nUn raster multibanda es un array de tres dimensiones con información de referencia espacial. Por lo anterior, debemos cubrir estos tipos de estructuras de datos en R.\n\n\n3.2.6 Matrix\nSe crea con la función matrix\nMatriz Vacía\n\nlibrary(raster)\n\nmi_matriz <- matrix(ncol= 3,nrow = 3) # crear una matriz vacía\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n\nplot(raster(mi_matriz), col = heat.colors(9, rev = T),\n     main = \"Matriz Vacía\")\n\n\n\n\nMatriz con valores\n\nvalores <-  1:9\nmi_matriz <- matrix(data = valores, ncol= 3, nrow = 3) # crear una matriz\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nplot(raster(mi_matriz), col = heat.colors(9, rev = T),\n     main = \"Matriz con Valores\")\n\n\n\n\nla función matrix, tiene los siguientes argumentos:\n\ndata: The vector of values for the matrix (for example, 1:6)\nnrow: The number of rows\nncol: The number of columns (for example, 3)\nbyrow: Whether the matrix is filled column by column (FALSE, which is the default value) or row by row (TRUE)\n\nSubset sobre una Matriz\n\nx <- mi_matriz\nx[, c(1,3)] # leer todas las filas, y columnas 1 y 3\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n\nx[2, ] # devolver fila 2 como vector \n\n[1] 2 5 8\n\nx[2, , drop = FALSE] # devolver fila 2 como dataframe\n\n     [,1] [,2] [,3]\n[1,]    2    5    8\n\n\nTrasponer una matriz\n\nmi_matriz\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nt(mi_matriz)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nAplicar funciones con apply() sobre una matriz\n\napply(x, MARGIN = 2, FUN = mean) # aplicar funciones \n\n[1] 2 5 8\n\n# MARGIN = 2 significar que se aplicarzá la función por columna\n# MARGIN = 1 significar que se aplicarzá la función por fila\n\nFunciones de alto performance (escritas en c++)\n\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\ncolSums(x) #suma de columnas\n\n[1]  6 15 24\n\ncolMeans(x) # promedio por columna\n\n[1] 2 5 8\n\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nrowSums(x) #Suma por fila\n\n[1] 12 15 18\n\nrowMeans(x) # promedio por fila\n\n[1] 4 5 6\n\n# PD: sirven también para dataframe y arrays\n\nEjemplo de martiz sin referencia espacial\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nimage(volcano, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\ncontour(volcano, add = TRUE)\n\n\n\n\n\n# install.packages(\"plot3D\")\nlibrary(plot3D)\n# reducir dimensionalidad\nVolcano <- volcano[seq(1, nrow(volcano), by = 3),\n                     seq(1, ncol(volcano), by = 3)]\n\npersp(Volcano, theta = 40, phi = 40, col = \"orange\", border = NA, shade = 0.5)\n\n\n\n\nsubset (corte transversales)\n\nr30 = volcano[30, ]  # Row 30\nr60 = volcano[60, ]  # Row 60\nvolcan <-  volcano \nvolcan[60, ] <- NA\nvolcan[30, ] <- NA\n\npar(mfrow=c(1,2))\nimage(volcan, col = terrain.colors(30), asp = ncol(volcano) / nrow(volcano))\nplot(r30, type = \"l\", col = \"blue\", ylim = range(c(r30, r60)), ylab = \"Elevation (m)\")\nlines(r60, type = \"l\", col = \"red\")\n\n\n\npar(mfrow=c(1,1))\n\n\n\n3.2.7 Arrays\n\n\n\nRepresentan estructuras de datos con dos o mas dimensiones, y se crean con la función “array”. Crearemos un objeto de 2 filas, 2 columnas y 3 dimensiones.\n\n# ?array\nvalores <- 1:24\nvalores\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\ny <- array(data = valores, dim =  c(2,4,3)) # dim(n_filas, , n_col, n_dimensiones(capas)) \ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\n\nSubset un array\n\ny\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24\n\ny[2,1,3] # seleccionar fila 2, columna 1, dimensión 3\n\n[1] 18\n\ny[2,1,] # seleccionar fila 2, columna 1, de todas las dimensiones\n\n[1]  2 10 18\n\n\n\n\n3.2.8 Estructura de Datos de Raster\nUn raster es una grilla rectangular de valores numéricos referenciados en cierta extensión geográfica. Puede tener una (matriz) o múltiples bandas (arrays).\nEn R para el tratamiento de objetos Raster se utiliza el package raster, de acuerdo a contenidos programadas de esta clase solo veremos las funciones básicas, pero con ejemplos que representa el mundo real.\nCaracterística importante del package raster que tienen la capacidad de trabajar con grandes raster (de mayor peso que la RAM de nuestros Equipos), donde automáticamente escribe el archivo temporal en el disco duro.\n\n\n\n\n\nlibrary(raster)\n\nz <- raster() # crear un raster vacio\nz\n\nclass      : RasterLayer \ndimensions : 180, 360, 64800  (nrow, ncol, ncell)\nresolution : 1, 1  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs"
  },
  {
    "objectID": "fundamentos_PR.html#sec-crearRaster",
    "href": "fundamentos_PR.html#sec-crearRaster",
    "title": "3  S1: Percepción Remota",
    "section": "3.3 Crear Raster",
    "text": "3.3 Crear Raster\nagregar argumentos\n\n?raster()\nx <- raster(ncol=36, nrow=18, # cantidad de filas y columnas\n            xmn=-1000, xmx=1000, ymn=-100, ymx=900)# extent (representación espacial)\nx\n\nclass      : RasterLayer \ndimensions : 18, 36, 648  (nrow, ncol, ncell)\nresolution : 55.55556, 55.55556  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n# plot(x)\n\nResolución espacial\n\nres(x)\n\n[1] 55.55556 55.55556\n\nres(x) <- 100\nres(x)\n\n[1] 100 100\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 20, 200  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : NA \n\n\nCambiar Numero de columnas (afecta la resolución)\n\nncol(x)\n\n[1] 20\n\nncol(x) <- 18\nncol(x)\n\n[1] 18\n\nres(x)\n\n[1] 111.1111 100.0000\n\n\ndefinir sistema de referencia de coordenadas\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nprojection(x) <- crs_latlon\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \n\n\nPero Hasta acá nuestro objeto Raster no tiene valores\n\nhasValues(x) # consultar si raster tiene valores\n\n[1] FALSE\n\nncell(x) #cantidad de celdas\n\n[1] 180\n\nvalues(x) <- 1:ncell(x) # ncell (cantidad de celdas del raster)\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nVisualización\n\nlibrary(RColorBrewer)\n# display.brewer.all()\ncolores <- brewer.pal(n = 8, name = 'BrBG') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(c(colores))( 180 ) # 200 colores \nplot(x, col = pal_col)\n\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 180  (min, max)\n\n\nmodificación de valores del Raster\n\nset.seed(42)\nvalues(x) <- runif(ncell(x))\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nFunciones\n\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1] 111.1111 100.0000\n\ndim(x)\n\n[1] 10 18  1\n\nxmax(x)\n\n[1] 1000\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 111.1111, 100  (x, y)\nextent     : -1000, 1000, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n\nCambiar el maximum de la coordenada x del extent (bounding box)\n\nxmax(x) <- 0\nhasValues(x)\n\n[1] TRUE\n\nres(x)\n\n[1]  55.55556 100.00000\n\ndim(x)\n\n[1] 10 18  1\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 18, 180  (nrow, ncol, ncell)\nresolution : 55.55556, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nplot(x, main = \"Raster de 180 celdas\", col = pal_col)\n\n\n\n\nsi modifico ncol desaparece los valores\n\nncol(x) <- 10\nhasValues(x)\n\n[1] TRUE\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\n# plot(x, col = pal_col)\n\n\n3.3.1 Operaciones básicas sobre un Raster\n\nOperaciones Básicas : **+, -, *, / **\nOperadores Lógicos >, >=, <, ==, !\nOtras Funciones: abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, atan, tan, max, min, range, prod, sum, any, all.\n\n\nx\n\nclass      : RasterLayer \ndimensions : 10, 10, 100  (nrow, ncol, ncell)\nresolution : 100, 100  (x, y)\nextent     : -1000, 0, -100, 900  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 0.0002388966, 0.9888917  (min, max)\n\nvalues(x) <- 1:ncell(x)\nr <- x\ns <- r + 10\ns <- sqrt(s)\ns <- s * r + 5\n\n# plot(s, col = pal_col)\n\n\nr[] <- runif(ncell(r))\nr <- round(r)\n\nplot(r, col = pal_col)\n\n\n\n\n\n\n3.3.2 Funciones con calc\n\nr <- raster(ncol=3, nrow=2)\nr[] <- 1:ncell(r)\ngetValues(r)\n\n[1] 1 2 3 4 5 6\n\nas.matrix(r)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n# cambiar los valores menores de 4 a NA\ns <- calc(r, fun=function(x){ x[x < 4] <- NA; return(x)} )\nas.matrix(s)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    4    5    6\n\n\nFunciones con overlay (entre layers)\n\n# Overlay\nw <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )\nas.matrix(w)\n\n     [,1]     [,2]     [,3]\n[1,]   NA       NA       NA\n[2,]    6 6.118034 6.224745\n\n\nFunciones con reclasify\n\n# Cambiar los valores entre 0 y 2 a 1, etc.\nx <- reclassify(w, c(0,2,1, \n                     2,5,2, \n                     4,10,3))\nas.matrix(x)\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    3    3    3\n\n\nmodificaciones sobre raster volcán\n\nclass(volcano)\n\n[1] \"matrix\" \"array\" \n\ndim(volcano)\n\n[1] 87 61\n\nvolcan <- raster(volcano)\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\ncolores <- brewer.pal(n = 8, name = 'GnBu') # YlGnBu 'YlGnBu\npal_col <- colorRampPalette(colors = rev(colores))( 180 ) # 200 colores \nplot(volcan, col =pal_col)\n\n\n\n\nfunciones con volcán\n\n# View(as.matrix(volcan))\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x < 100] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n# escenario de inundación\nvolcan_mod  <- calc(volcan, fun=function(x){ x[x > 120] <- NA; return(x)} )\nplot(volcan_mod, col =pal_col)\n\n\n\nvm <-  as.matrix(volcan_mod)\npersp(vm, theta = 40, phi = 10, col =  \"gold\", border = NA, shade = 0.5)\n\n\n\n\n\n\n3.3.3 Reclasificar con volcan\n\nvolcan\n\nclass      : RasterLayer \ndimensions : 87, 61, 5307  (nrow, ncol, ncell)\nresolution : 0.01639344, 0.01149425  (x, y)\nextent     : 0, 1, 0, 1  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : layer \nvalues     : 94, 195  (min, max)\n\nrecla_vocan <- reclassify(x = volcan,\n                          rcl = c(0,100,NA, \n                                  100,140,1, \n                                  140,180,2,\n                                  180, 200, 3))\nplot(recla_vocan)\n\n\n\n\n\n\n3.3.4 Crear Raster Mulitibanda\n\n\n\nPara crear una raster multibanda (RasterLayer) utilizaremos la función stack()\n\nr1 <- r2 <- r3 <- raster(nrow=10, ncol=10)\n# Assign random cell values\nvalues(r1) <- runif(ncell(r1))\nvalues(r2) <- runif(ncell(r2))\nvalues(r3) <- runif(ncell(r3))\n\ns <- stack(r1, r2, r3)\ns\n\nclass      : RasterStack \ndimensions : 10, 10, 100, 3  (nrow, ncol, ncell, nlayers)\nresolution : 36, 18  (x, y)\nextent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nnames      :      layer.1,      layer.2,      layer.3 \nmin values : 0.0023781068, 0.0014338985, 0.0004050434 \nmax values :    0.9907958,    0.9802787,    0.9930453 \n\nnlayers(s)\n\n[1] 3\n\n\n\nb1 <- brick(r1, r2, r3)\n\nLeer un raster de ejemplo\n\nfilename <- system.file(\"external/test.grd\", package=\"raster\")\nfilename\n\n[1] \"/Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library/raster/external/test.grd\"\n\nr_test <- raster(filename)\n# filename(r)\nhasValues(r_test)\n\n[1] TRUE\n\nplot(r_test, main='RasterLayer from file', col = pal_col)\n\n\n\n\n\nr1 <- r_test\nr2  <- calc(r_test, fun=function(x){ x[x < 500] <- NA; return(x)})\n\nr3 <- reclassify(x = r_test,\n                          rcl = c(0,300,1, \n                                  300,500,2, \n                                  500,1000,3,\n                                  1000, 2000, 4))\n\nbrick_raster <- brick(r1, r2, r3)\n\nVisualización dinámica\n\nlibrary(mapview)\npal = mapviewPalette(\"mapviewTopoColors\")\nm <- mapview(brick_raster, alpha = 0.5)\nm@map\n\n\n\n\n\n\n\n3.3.5 Guardar Raster\n\n# dir.create(path = \"data/raster\")\nwriteRaster(r_test, \"data/r_test1.tif\")"
  },
  {
    "objectID": "satelites_sensores.html#satélites",
    "href": "satelites_sensores.html#satélites",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.1 Satélites",
    "text": "4.1 Satélites\n\n4.1.1 Definición de Satélite\nUn satélite es una plataforma que describe una trayectoria definida alrededor de la Tierra denominada órbita. Existen dos tipos de satélites: geoestacionarios y heliosíncronos.\n\n\n\n\n\n\n\n4.1.2 Clasificación de Satélites por tipo de órbita\n\nGeoestacionarios:\n\nSobre la línea ecuatorial, a 36.000 km de la Tierra, realiza una vuelta alrededor de nuestro planeta al mismo tiempo que efectúa una rotación completa alrededor de su propio eje. Comunicaciones y meteorología.\n\n\n\n\n\n\n\n\nHeliosíncronos:\n\nÓrbitas circulares y polares relativo a la tierra a 160-2000 km. Captan imágenes con regularidad sobre un mismo punto o escena."
  },
  {
    "objectID": "satelites_sensores.html#sensores",
    "href": "satelites_sensores.html#sensores",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.2 Sensores",
    "text": "4.2 Sensores\n\n4.2.1 Definción de Sensor\nUn sensor es un instrumento a bordo de una plataforma capaz de adquirir remotamente información de diferentes regiones del espectro. Cada una de estas regiones se denomina canal o banda espectral. Existen dos tipos de sensores: activos y pasivos.\n\n\n4.2.2 Clasificación de Sensores\n\nSensores Activos:\n\nGeneran su propia radiación y la reciben reflejada (Radar y LiDAR)\n\nSensores Pasivos:\n\nMiden energía radiante reflejada o emitida por el sistema tierra- atmósfera. Ejemplo Landsat, Sentinel, MODIS.\n\n\n\n\n4.2.3 Características de los Sesores\nLa energía emitida o reflejada por la superficie terrestre es un fenómeno continuo en 4 cuatro dimensiones: espacio, tiempo, longitud de onda y radiancia.\n\nResolución espacial:\n\nTamaño del pixel o celda del raster que contiene a la banda espectral (Landsat: 30 m x 30 m)\n\nResolución temporal:\n\nTiempo entre imágenes sucesivas (Landsat 16 días)\n\nResolución espectral:\n\nNúmero y rango de las regiones del espectro electromagnético para los que capta información el sensor .\n\nResolución radiométrica:\n\nIndica el número de intervalos de intensidad que puede captar el sensor (escala de grises) (Landsat 5 y 7: 256)\n\n\n\n\n4.2.4 Resolución Espacial\nResolución espacial: Tamaño del pixel o celda del raster que contiene a la banda espectral (Landsat: 30 m x 30 m)\n\n\n\n\n\n\n\n4.2.5 Resolución Temporal:\nEl tiempo que tarda un satélite en completar un ciclo orbital; también conocido como “tiempo de revisita”.\n\n\n\n\n\nDepende de las capacidades, solapa de barrido y latitud del satélite/sensor. Algunos satélites pueden apuntar sus sensores y algunos además tienen una mayor solapa en latitudes superiores así que posiblemente tengan un mayor tiempo de repetición .\n\n\n4.2.6 Resolución Espectral:\nNúmero y rango de las regiones del espectro electromagnético para los que capta información el sensor.\n\n\n\n\n\nDescribe la habilidad del sensor de definir intervalos de longitudes de onda. Cuanto más fina la resolución espectral, más estrecha la gama de longitudes de onda para un canal o banda en particular. Tener más y más finos canales permite la percepción remota de diferentes partes de la superficie de la Tierra.\n\n\n4.2.7 Resolución Radiométrica:\nIndica el número de intervalos de intensidad que puede captar el sensor. El número máximo de niveles de luminosidad disponible depende del número de bits que se utilizan en la representación de la energía registrada.\n\n\n\n\n\nCuanto mayor este número, más alta la resolución radiométrica y más nítidas las imágenes, representada por números digitales positivos que varían del 0 a (uno menos que) alguna potencia de 2.\n\n\n\n\n \n  \n    Nro.Bits \n    Sensor \n    Potencias \n    Niveles \n  \n \n\n  \n    12 Bits \n    MODIS \n    2^12 \n    4096 niveles \n  \n  \n    10 Bits \n    AVHRR \n    2^10 \n    1024 niveles \n  \n  \n    8 Bits \n    Landsat TM (Thematic Mapper) \n    2^8 \n    256 niveles \n  \n  \n    6 Bits \n    Landsat MSS (Multispectral Scanner System) \n    2^6 \n    64 niveles"
  },
  {
    "objectID": "satelites_sensores.html#correcciones-en-imágenes-satelitales",
    "href": "satelites_sensores.html#correcciones-en-imágenes-satelitales",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.3 Correcciones en Imágenes Satelitales",
    "text": "4.3 Correcciones en Imágenes Satelitales\nLas imágenes satelitales se encuentran expuestas a una serie de interferencias que pueden llegar a perturbar la información espacial, principalmente asociadas a una serie de errores mecánicos de los sensores o a interferencias atmosféricas.\n\nCorrección radiométrica: Corrige fallos en los sensores.\nCorrección geométrica: Alteraciones en los movimientos de los satélites generan distorsiones en la imagen.\nCorrección topográfica: El efecto topográfico provoca una variación de la respuesta radiométrica de la superficie inclinada frente a la de una horizontal (efecto sombra)\nCorrección atmosférica: Corrige las interferencias atmosféricas (vapor de agua)\n\n\n\n\n\n\nAlgunos productos satelitales son diponibilizados con una o varias correcciones y dependendiendo los tipos de correcciones se dividen en niveles."
  },
  {
    "objectID": "satelites_sensores.html#satélites-más-utilizados",
    "href": "satelites_sensores.html#satélites-más-utilizados",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.4 Satélites más Utilizados",
    "text": "4.4 Satélites más Utilizados\nGoogle Earth Engine ofrece un Earth Engine Data Catalog de todos los productos satelitales disponibles en su plataforma, que cuenta con información relevante y como usarse. A continucación se especifica dos de sensores óptimos más utilizados\n\n4.4.1 Landsat 8\n\n\n\n\n\nLandsat 8 es un satélite de observación terrestre estadounidense lanzado el 11 de febrero de 2013. operado en la colaboración de la NASA con el USGS. El estudio de los datos se realiza mediante dos sensores principales. El satélite opera en luz visible, infrarrojo cercano, infrarrojo de onda corta e infrarrojo térmico (de onda larga). Las bandas de Landsat 8 están configuradas en 11 diferentes en base a la longitud de onda de su visión. (Catálogo gee Landsat 8)\n\n\n\n\n\nUno de los sensores del Landsat 8, Operational Land Imager (OLI), usa 9 bandas en el espectro de la luz visible y el infrarrojo cercano. Otro de los sensores del Landsat 8, Thermal InfraRed Sensor (TIRS), opera en el rango de infrarrojos de onda larga (Longwave InfraRed Light). El satélite proporciona imágenes con una resolución moderada que varía en diferentes bandas desde 15 m por píxel en la más precisa hasta 100 m en el infrarrojo de onda larga, donde la precisión no es vital.\n\n\n\n\n \n  \n    Banda \n    Nombre \n    Longitud_de_onda_(μm) \n    Resolución(m) \n  \n \n\n  \n    1 \n    Costera - Aerosoles \n    0.435 - 0.451 \n    30 \n  \n  \n    2 \n    Azul \n    0.452 - 0.512 \n    30 \n  \n  \n    3 \n    Verde \n    0.533 - 0.590 \n    30 \n  \n  \n    4 \n    Rojo \n    0.636 - 0.673 \n    30 \n  \n  \n    5 \n    Infrarrojo cercano (NIR) \n    0.851 - 0.879 \n    30 \n  \n  \n    6 \n    Infrarrojo de onda corta 1 (SWIR 1) \n    1.566 - 1.651 \n    30 \n  \n  \n    10 \n    (TIR 1) \n    10.60 - 11.19 \n    100 \n  \n  \n    11 \n    (TIR 2) \n    11.50 - 12.51 \n    100 \n  \n  \n    7 \n    Infrarrojo de onda corta 2 (SWIR 2) \n    2.107 - 2.294 \n    30 \n  \n  \n    8 \n    Pancromática \n    0.503 - 0.676 \n    15 \n  \n  \n    9 \n    Cirrus \n    1.363 - 1.384 \n    30 \n  \n\n\n\n\n\n\n\n4.4.2 Sentinel 2\n\n\n\n\n\nSentinel-2 es una misión de observación terrestre desarrollada por la ESA dentro del programa Copérnico. Está compuesto por dos satélites idénticos: Sentinel-2A (junio de 2015) y Sentinel-2B (marzo de 2017). (Catálogo gee Sentinel-2)\nCaracterísticas:\n\nImagen multiespectral datos con 13 bandas\nSentinel-2 realiza las labores cada 5 días, pero con diferentes ángulos de visión.\nLa resolución espacial de 10m, 20m y 60m\nPolítica de datos libre y en abierto\n\n\n\n\n\n \n  \n    Banda \n    Nombre \n    Central.Wavelength \n    Resolución.m. \n  \n \n\n  \n    B1 \n    Ultra Blue (Coastal and Aerosol) \n    443 nm \n    60 m \n  \n  \n    B2 \n    Blue \n    490 nm \n    10 m \n  \n  \n    B3 \n    Green \n    560 nm \n    10 m \n  \n  \n    B4 \n    Red \n    665 nm \n    10 m \n  \n  \n    B5 \n    Visible and Near Infrared (VNIR) \n    705 nm \n    20 m \n  \n  \n    B6 \n    Visible and Near Infrared (VNIR) \n    740 nm \n    20 m \n  \n  \n    B7 \n    Visible and Near Infrared (VNIR) \n    783 nm \n    20 m \n  \n  \n    B8 \n    Visible and Near Infrared (VNIR) \n    842 nm \n    10 m \n  \n  \n    B8a \n    Visible and Near Infrared (VNIR) \n    865 nm \n    20 m \n  \n  \n    B9 \n    Short Wave Infrared (SWIR) \n    940 nm \n    60 m \n  \n  \n    B10 \n    Short Wave Infrared (SWIR) \n    1375 nm \n    60 m \n  \n  \n    B11 \n    Short Wave Infrared (SWIR) \n    1610 nm \n    20 m \n  \n  \n    B12 \n    Short Wave Infrared (SWIR) \n    2190 nm \n    20 m \n  \n\n\n\n\n\nMas referencias aquí\n\nFinalmente se presenta una comparación la resolución espectral Landsat 8 y Sentinel-2:"
  },
  {
    "objectID": "satelites_sensores.html#tratamiento-de-imágenes-satelitales",
    "href": "satelites_sensores.html#tratamiento-de-imágenes-satelitales",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.5 Tratamiento de Imágenes Satelitales",
    "text": "4.5 Tratamiento de Imágenes Satelitales\nA continuación se hara una serie de operaciones sobre una imagen satelital LANDSAT 8 recortada por un área de estudio correspondiente a la comuna de Las Condes.\n\n4.5.1 Lectura de Imagen Satelital\n\nlibrary(raster)\nLC <- brick(\"data/raster/OLI_LC.tif\")\nnames(LC) <- c(\"aerosol\",\"blue\", \"green\", \"red\", \"nir\", \"swir1\", \"swir2\", \"tir1\" )\nLC\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : OLI_LC.tif \nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2,  tir1 \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,  5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,  5512 \n\n\n\n\n4.5.2 Visualización Básica Imagen Satelital\n\n\n\n\n# Color Natural\nplotRGB(LC, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n\n\nlibrary(mapview)\nviewRGB(LC,   r = 4, g = 3, b = 2)\n\n\n\n\n\n\n\n4.5.3 Reproyección de Imagen Satelital\nDefinir Sistemas de Referencias como variables\n\n### latlon Utilizado a escala mundial\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"\n\n### utm utilizado a nivel regional (depende de la zona y hemisferio)\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n\n\nLC_ll <- raster::projectRaster(LC, crs = crs_latlon)\n\n\n\n4.5.4 Recorte Imagen Satelital\n\n## crop y mask\n# ext <- drawExtent()\next <- extent(c(350638, 358235,  6299157, 6304228))\nLC_crop <- crop(x = LC, y = ext, snap=\"out\")\n# LCondes <- mask(r2, ext)\nplotRGB(LC_crop, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n\n\n\n4.5.5 Combinaciones de Bandas de Imagen Satelital\n\n\n\nNúmero de bandas asignado a la Imagen OLI Landsat\n\naerosol = 1\nblue = 2\ngreen = 3\nred = 4\nnir = 5\nswir1 = 6\nswir2 = 7\nthermal = 8\n\nLas Condes: Color Natural (4,3,2)\n\nplotRGB(LC, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Falso Color (7,6,4)\n\nplotRGB(LC, r = 7, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Infrarojo (5,4,3)\n\nplotRGB(LC, r = 5, g = 4, b = 3, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Agricultura (6,5,2)\n\nplotRGB(LC, r = 6, g = 5, b = 2, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Penetración de la Radiación en la Atmósfera (7,6,5)\n\nplotRGB(LC, r = 7, g = 6, b = 5, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Uso del Suelo / Masas de Agua (5,6,4)\n\nplotRGB(LC, r = 5, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Infrarojo de Onda Corta (7,5,4)\n\nplotRGB(LC, r = 7, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Análisis de Vegetación (6,5,4)\n\nplotRGB(LC, r = 6, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\nLas Condes: Análisis de Vegetación Sana (5,6,2)\n\nplotRGB(LC, r = 5, g = 6, b = 2, stretch = \"lin\")"
  },
  {
    "objectID": "satelites_sensores.html#ndvi",
    "href": "satelites_sensores.html#ndvi",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.6 NDVI",
    "text": "4.6 NDVI\n\n4.6.1 Cálculo de NDVI\n\n\n\n\nFormula para el cáculo de NDVI\n\n\n\nMetódo 1\n\n#NDVI(img, red, NIR)\nNDVI <- function(img, r, n) {\n   br <- img[[r]]\n   bn <- img[[n]]\n   vi <- (bn - br) / (bn + br)\n   return(vi)\n}\nNDVI_lc <- NDVI(LC, 4, 5)\nplot(NDVI_lc , main = \"NDVI Las Condes\")\n\n\n\n\n\n\n4.6.2 Histograma de valores NDVI\n\n# dev.off()\nhist(NDVI_lc, col=\"springgreen4\", main=\"Histograma NDVI Las Condes\",\n  ylab=\"Numero de Pixeles\", xlab=\"valor NDVI\")\n\n\n\n\n\n\n\n\n\n\n4.6.3 reclasificación de NDVI\nTodo lo que sea igual o menor que value será lo demàs conserva su valor\n\ncorte_eq_menor<- function(value) {\n  function(x){ifelse(x <= value,NA, x)}\n}\nvegetacion <- calc(NDVI_lc, fun = corte_eq_menor(value = 0.4))\nplot(vegetacion)"
  },
  {
    "objectID": "satelites_sensores.html#visualización-avanzada-de-raster",
    "href": "satelites_sensores.html#visualización-avanzada-de-raster",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.7 Visualización Avanzada de Raster",
    "text": "4.7 Visualización Avanzada de Raster\n\n4.7.1 Visualziación Estática\nZonas de Vegetación ALta en Las Condes\n\n# crear una paleta de colores con 200 niveles \npal_green <- colorRampPalette(c(\"green\",\"springgreen4\", \"darkgreen\"))( 200 )\nplot(vegetacion , main = \"NDVI Vegetación Alta\", col = pal_green)\n\n## agregar Las polígono de Las Condes\nLasCondes <- sf::st_read(\"data/shape/LasCondes.shp\")\n\nReading layer `LasCondes' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII/data/shape/LasCondes.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 350513.9 ymin: 6293910 xmax: 367354.6 ymax: 6307356\nProjected CRS: WGS 84 / UTM zone 19S\n\nplot(LasCondes$geometry, add = T, )\n\n\n\n\n### Visualización Dinámica\nVersión con Mapview\n\n# install.packages(\"mapview\")\n\nmview <- mapview(LasCondes, color = \"#05A39B\", alpha.region =0)+\n  viewRGB(LC, r = 4, g = 3, b = 2, na.color = \"transparent\")+ \n  mapview(vegetacion, na.color = \"transparent\") +\n  mapview(NDVI_lc, na.color = \"transparent\") \n\n  \nmview\n\n\n\n\n\n# Mostrar opciones de guardar resultados dinámicos\n\nbonus guardar html\n\nmapshot(x = mview, url = \"mapa_veg.html\")\n\nVersión con librería Leaflet (compleja)\n\nsuppressPackageStartupMessages(library(leaflet))\nNDVI_lc_ll <- projectRaster(vegetacion, \n                            crs = \"+proj=longlat +datum=WGS84 +no_defs\")\n\nLasCondes <- sf::st_transform(LasCondes, crs_latlon)\n\n# se construye una función para asignar valores dado un valor\npal <- colorNumeric(c(\"green\",\"springgreen4\", \"darkgreen\"), \n                    values(NDVI_lc_ll), na.color = \"transparent\")\n\nmap <- leaflet() %>% \n  addTiles(group = \"OSM (default)\") %>%  \n  addProviderTiles(providers$Stamen.Toner, group = \"Toner\") %>%\n  addProviderTiles(providers$Stamen.TonerLite, group = \"Toner Lite\") %>%\n  addProviderTiles(providers$Esri.WorldImagery, group = \"Satellite\")%>%\n  addRasterImage(NDVI_lc_ll, colors = pal, opacity = 1, group = \"NDVI\") %>%\n  addLegend(position = \"bottomright\", pal = pal, values = values(NDVI_lc_ll),\n            opacity = 1, group = \"NDVI\", title = \"NDVI\")%>%\n  addPolygons(data = LasCondes, color =  \"navy\", \n              fillOpacity = 0, weight = 3)%>%\n  addLayersControl(position = \"topright\",\n                   baseGroups = c(\"Toner Lite\",\"Satellite\", \n                                  \"OSM (default)\", \"Toner\"),\n                   overlayGroups = \"NDVI\",\n                   options = layersControlOptions(collapsed = TRUE))\nmap"
  },
  {
    "objectID": "satelites_sensores.html#repasar-instalación-de-rgee",
    "href": "satelites_sensores.html#repasar-instalación-de-rgee",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.8 Repasar Instalación de Rgee",
    "text": "4.8 Repasar Instalación de Rgee\nInstalar Librerías Previas\n\ninstall.packages(\"reticulate\")\ninstall.packages(\"jsonlite\")\n\nInstalar Rgee\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"r-spatial/rgee\", force = TRUE)\ninstall.packages(\"rgee\")\n\nInstalar Ambiente Virtual\n\n## It is necessary just once\nee_install() \n\n# indicar \"Yes\"\n# Ahora de debe reiniciar Rstudio\n\nTest de Instalación Correcta\n\nlibrary(tidyverse)\nlibrary(rgee)\nlibrary(sf)\nee_Initialize()\n\n── rgee 1.1.5 ─────────────────────────────────────── earthengine-api 0.1.335 ── \n ✔ user: not_defined\n ✔ Initializing Google Earth Engine:\n ✔ Initializing Google Earth Engine:  DONE!\n\n ✔ Earth Engine account: users/denisberroeta \n──────────────────────────────────────────────────────────────────────────────── \n\ncreateTimeBand <-function(img) {\n  year <- ee$Date(img$get('system:time_start'))$get('year')$subtract(1991L)\n  ee$Image(year)$byte()$addBands(img)\n}\n\ncollection <- ee$\n  ImageCollection('NOAA/DMSP-OLS/NIGHTTIME_LIGHTS')$\n  select('stable_lights')$\n  map(createTimeBand)\n\ncol_reduce <- collection$reduce(ee$Reducer$linearFit())\ncol_reduce <- col_reduce$addBands(\n  col_reduce$select('scale'))\n# ee_print(col_reduce)\n\n\nMap$setCenter(9.08203, 47.39835, 3)\nm <- Map$addLayer(\n  eeObject = col_reduce,\n  visParams = list( bands = c(\"scale\", \"offset\", \"scale\"),\n                    min = 0,    max = c(0.18, 20, -0.18)),\n  name = \"stable lights trend\")\nm"
  },
  {
    "objectID": "satelites_sensores.html#referencias",
    "href": "satelites_sensores.html#referencias",
    "title": "4  S2: Satélites y Sensores",
    "section": "4.9 Referencias",
    "text": "4.9 Referencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nReferencias de Mapview\nhttps://r-spatial.github.io/mapview/reference/index.html\nReferencias de Leaflet\nhttps://rstudio.github.io/leaflet/"
  },
  {
    "objectID": "intro_gee.html#plataforma-de-google-earth-engine-gee",
    "href": "intro_gee.html#plataforma-de-google-earth-engine-gee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.1 Plataforma de Google Earth Engine (GEE)",
    "text": "5.1 Plataforma de Google Earth Engine (GEE)\n\n\n\n\n\nGoogle Earth Engine es una plataforma de geomática basada en la nube que permite a los usuarios visualizar y analizar imágenes de satélite de nuestro planeta.\nLos científicos y las organizaciones sin ánimo de lucro utilizan Google Earth Engine para llevar a cabo estudios de teledetección remota, predecir brotes de enfermedades, gestionar recursos naturales, etc. Los estudiantes pueden acceder a esta información para participar en los debates y convertirse en científicos de datos.\n\n\n\n\n\nUso es libre pero no es código abierto y contiene:\n\nInfraestructura\nDatos\nAPI\nCode Editor"
  },
  {
    "objectID": "intro_gee.html#infraestructura-de-gee",
    "href": "intro_gee.html#infraestructura-de-gee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.2 Infraestructura de GEE",
    "text": "5.2 Infraestructura de GEE\nLa Infraestructura de Google pone a disposición del usuario sus servidores, permitiendo así hacer análisis en paralelo con cerca de 10.000 CPUs.\n\n\n\nDiseño de general del flujo de trabajo en la infraestrucura de GEE\n\n\nEjemplo: El desarrollo del mapa global sin nubes a 15 m de resolución de Google Earth y Google Maps, usando estos servidores, tardó un par de días, mientras que, si se hubiera usado una computadora personal la demora habría sido de 14 años (Gorelick et al. 2017).\n\n\n\nCompración del flujo de trabajo regular versus el flujo de trabajo con Google Earth Engine."
  },
  {
    "objectID": "intro_gee.html#recursos-satelitales",
    "href": "intro_gee.html#recursos-satelitales",
    "title": "5  S3: Introducción a GEE",
    "section": "5.3 Recursos Satelitales",
    "text": "5.3 Recursos Satelitales\nGoogle tiene almacenado todas las imágenes de varios sensores (Landsat, Sentinel, MODIS, entre otros). Estas bases de datos se actualizan a medida que se toman nuevas imágenes (cerca de 6000 nuevas escenas diarias). Sin necesidad de descargar ni solicitar acceso a las imágenes.\nEarth Engine Data Catalog\n\n\n\nRescursos Satelitales disponibles en Google Earth Engine."
  },
  {
    "objectID": "intro_gee.html#apis",
    "href": "intro_gee.html#apis",
    "title": "5  S3: Introducción a GEE",
    "section": "5.4 APIs",
    "text": "5.4 APIs\nLas API (Application Program Interface) consiste en utilizar una serie de comandos y funciones preestablecidas para el procesamiento geoespacial, escrita en Javascript y Python.\n\n\n\nLos lenguajes ificiales para interactuar con GEE mediante APIs es Javascript y Python\n\n\nDocumentación de la APIs general\nSin embargo, dichas funciones no pueden modificarse ni tampoco se puede acceder a su código, lo cual impide al usuario realizar modificaciones para lograr análisis alternativos a los preestablecidos.\n\n\n\nDiferencias en la Sitanxis entre Javascript y Python\n\n\n\nPython:\n\nEs un lenguaje de programación interpretado cuya filosofía hace hincapié en la legibilidad de su código. Multipropósito.\n\n\n\nDocumentación en Python\n\n\nJavascript:\n\nEs un lenguaje de programación interpretado. Se define como orientado a objetos, basado en prototipos, imperativo, débilmente tipado y dinámico. Uso en la web.\n\n\n\nDocumentación en Javascript"
  },
  {
    "objectID": "intro_gee.html#editor-de-código-gee",
    "href": "intro_gee.html#editor-de-código-gee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.5 Editor de Código GEE",
    "text": "5.5 Editor de Código GEE\nEl Code Editor es el entorno de desarrollo integrado en línea, donde se juntan todos los elementos. Aquí es donde el usuario puede, a través de código de trabajo (“scripts”), llamar a los datos, procesar y visualizarlos de manera virtual con los servidores de Google, teniendo así sus resultados e información en la nube.\n\n\n\nInterface del Code Editor en linea"
  },
  {
    "objectID": "intro_gee.html#introducción-a-rgee",
    "href": "intro_gee.html#introducción-a-rgee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.6 Introducción a Rgee",
    "text": "5.6 Introducción a Rgee\n\n\n\n\n\nLa librería rgee es una “librería cliente” de Earth Engine para R, desarrollada por Aybar et al. (2020) que permite a los usuarios aprovechar las ventajas que presenta el ecosistema espacial de R dentro de Google Earth Engine y viceversa.\nTodas las clases, módulos y funciones de la API de Python de Earth Engine están disponibles en R gracias a la librería reticulate, finalmente rgee adiciona nuevos features como el diseño del imput y output de datos, la visualización en mapas interactivos, la facil extracción de series de tiempo, el manejo y la visualización de metadatos."
  },
  {
    "objectID": "intro_gee.html#instalación-de-rgee",
    "href": "intro_gee.html#instalación-de-rgee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.7 Instalación de Rgee",
    "text": "5.7 Instalación de Rgee\nInstalar Librerías Previas (solo si no las tiene instaladas)\n\ninstall.packages(\"jsonlite\")\ninstall.packages(\"reticulate\")\ninstall.packages('cptcity') #Para manejar paletas decolores\ninstall.packages('viridis') #Para manejar paletas decolores\ninstall.packages('ggmap') # Para manejar tipos de basemap\n\nInstalar rgee (solo si no tiene la librería instalada)\n\n# remotes::install_github(\"r-spatial/rgee\", force = TRUE)\nlibrary(rgee)\nee_install() \n# en la consola poner \"y\" \n\n# Eventuales soluciones a problemas de  version\n# * rgee::ee_install_upgrade()\n# * reticulate::py_install('earthengine-api==0.1.277')\n# * pip install earthengine-api==0.1.277 (Linux and Mac0S)\n# * conda install earthengine-api==0.1.277 (Linux, Mac0S, and Windows)\n\nCargar Librerías complementarias\n\nlibrary(mapview) \nlibrary(tidyverse) \nlibrary(sf) \nlibrary(raster) \nlibrary(cptcity) \nlibrary(ggmap)"
  },
  {
    "objectID": "intro_gee.html#estructura-de-información-rgee",
    "href": "intro_gee.html#estructura-de-información-rgee",
    "title": "5  S3: Introducción a GEE",
    "section": "5.8 Estructura de Información RGEE",
    "text": "5.8 Estructura de Información RGEE\nrgee presenta una sintaxis muy similar python o javasript, como se ilusta a continuación\n\n\n\n\n\n\nlibrary(rgee)\n# ee_check() #\nee_Initialize('denis.berroeta@gmail.com', drive = TRUE)\n\n── rgee 1.1.5 ─────────────────────────────────────── earthengine-api 0.1.335 ── \n ✔ user: denis.berroeta@gmail.com \n ✔ Google Drive credentials:\n ✔ Google Drive credentials:  FOUND\n ✔ Initializing Google Earth Engine:\n ✔ Initializing Google Earth Engine:  DONE!\n\n ✔ Earth Engine account: users/denisberroeta \n──────────────────────────────────────────────────────────────────────────────── \n\n\nCuando se apliquen funciones de gee a través de su interprete de python se debe reemplazar el operador . por $ al momento de anidar funciones.\nAunque si se debe tener en cuena otras consideraciones que se encuetran en esta página https://r-spatial.github.io/rgee/articles/considerations.html\nAcceso a Recursos Satelitales\n\n\n\n\n\nLos cátalogos de información satelitan se enuentran en Earth Engine Data Catalog, donde insluso tiene un buscador.\nSe puede explorar los catálos de Información con rgee, por ejemplo:\n\ndataset <- ee$ImageCollection('LANDSAT/LC08/C01/T1_8DAY_EVI')$\n  filterDate('2017-01-01', '2017-12-31')\n\n# ee_print(dataset)\n\n\nlandsat <- dataset$select('EVI')\n# class(landsat)\n\n# ee_print(landsat)"
  },
  {
    "objectID": "intro_gee.html#filtros-de-ubicación-fechas-y-metadata",
    "href": "intro_gee.html#filtros-de-ubicación-fechas-y-metadata",
    "title": "5  S3: Introducción a GEE",
    "section": "5.9 Filtros de Ubicación Fechas y Metadata",
    "text": "5.9 Filtros de Ubicación Fechas y Metadata\nA continuación se hara un consulta de imágenes disponibles en una obicación específica (punto), fechas (rango), y con cierta calidad (cobertura de nubes).\nSe definirán las coordenadas variables hacer la consulta de disponibilidad de recursos satelitales\n\n# Ubicación:\ncoordendas <- c(-71.6838, -33.4427) #isla negra\n# coordendas <- c(-70.66, -33.45) # Santiago\n# coordendas <- c(-70.15027, -20.21326) # Iquique\n# coordendas <- c(-73.04977, 36.82699) # Concepción\n# https://www.geodatos.net/coordenadas/chile/la-serena\n# Las coornadas se deben invertir\n\n\ndisponible <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$\n  filterDate('2021-01-01','2021-10-01')$\n  filterBounds(ee$Geometry$Point(coords = coordendas))$\n  filterMetadata('CLOUD_COVER','less_than', 10)\n\ndf_disponible <- ee_get_date_ic(disponible)%>%\n  arrange(time_start)# ordenar por fecha\n\ndf_disponible\n\n                                             id          time_start\n1  LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210112 2021-01-12 14:33:52\n2  LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210128 2021-01-28 14:33:48\n3  LANDSAT/LC08/C01/T1_TOA/LC08_001083_20210308 2021-03-08 14:39:46\n4  LANDSAT/LC08/C01/T1_TOA/LC08_001083_20210409 2021-04-09 14:39:35\n5  LANDSAT/LC08/C01/T1_TOA/LC08_001083_20210511 2021-05-11 14:39:24\n6  LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210605 2021-06-05 14:33:27\n7  LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210621 2021-06-21 14:33:32\n8  LANDSAT/LC08/C01/T1_TOA/LC08_001083_20210628 2021-06-28 14:39:44\n9  LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210707 2021-07-07 14:33:34\n10 LANDSAT/LC08/C01/T1_TOA/LC08_001083_20210831 2021-08-31 14:40:04\n11 LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210909 2021-09-09 14:33:56\n\n\nVisualizar una escena satelital de la lista\n\nescena <- df_disponible$id[1] # selección de primera\nescena\n\n[1] \"LANDSAT/LC08/C01/T1_TOA/LC08_233083_20210112\"\n\nviz = list(min = 0, max = 0.7, bands = c('B4','B3','B2'), gamma = 1.75)\nlandsat <- ee$Image(escena) \nMap$centerObject(eeObject = landsat,zoom = 8) \nMap$addLayer(eeObject = landsat,visParams = viz)"
  },
  {
    "objectID": "intro_gee.html#cálculo-de-ndvi-las-condes",
    "href": "intro_gee.html#cálculo-de-ndvi-las-condes",
    "title": "5  S3: Introducción a GEE",
    "section": "5.10 Cálculo de NDVI Las Condes",
    "text": "5.10 Cálculo de NDVI Las Condes\nLectura de Las Condes\n\n# Lectura de Las condes\nLasCondes <- sf::st_read(\"data/shape/LasCondes.shp\")%>%\n  st_transform(\"+proj=longlat +datum=WGS84 +no_defs\")\n\nReading layer `LasCondes' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII/data/shape/LasCondes.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 350513.9 ymin: 6293910 xmax: 367354.6 ymax: 6307356\nProjected CRS: WGS 84 / UTM zone 19S\n\n\nTransformar a formato Earth Engine\n\nLC_ee <- LasCondes%>%\n  sf_as_ee()\n\nregion <- LC_ee$geometry()$bounds()# selección bound\n\nCortar por Geometria de Las Condes\n\nlandsat_LC <- landsat$clip(LC_ee)\n\nCrear la Función NDVI\n\nNDVI_f <- function(image){\n   ndvi = image$expression(\"(nir - red) / (nir + red)\", \n                           list(nir =  image$select(\"B5\"),\n                                red = image$select(\"B4\")))$\n     rename(\"NDVI\")\n    return(ndvi)\n }\n\nAplicar la Función NDVI\n\nndvi_lc <- NDVI_f(landsat_LC)\n\nVisualización de Resultados de NDVI\n\npal_green <- colorRampPalette(c(\"green\",\"springgreen4\", \"darkgreen\"))( 200 )\n# pal_green <- c(\"#d73027\", \"#f46d43\", \"#fdae61\", \"#fee08b\", \"#d9ef8b\", \"#a6d96a\", \"#66bd63\", \"#1a9850\")\n\nviz <- list(palette = c(pal_green))\nMap$centerObject(region, zoom = 12) \nMap$addLayer(eeObject = ndvi_lc, visParams = viz)\n\n\n\n\n\n\n5.10.1 Transformar de Gee Object a Raster\nPara hacer esto lo que debe exportar la imagen satelital de dos forma principales\nForma 1: función ee_as_raster()\n\nndvi <- ee_as_raster(ndvi_lc)\n\nForma 2: Generando link de descarga\n\ngeom_params <-   list(scale = 30,  crs = 'EPSG:4326', region = region)\npath <- ndvi_lc$getDownloadUrl(geom_params)\nprint(path)\n\n[1] \"https://earthengine.googleapis.com/v1alpha/projects/earthengine-legacy/thumbnails/d8875638ab5d8a83e70c231e84a8461f-234dc3336ac73ccb92cea31ac011686c:getPixels\"\n\n# https://github.com/r-spatial/rgee/blob/examples/image/download.R\n\nForma 3: usando google drive. (recomendable para áreas de estudio mayores)\n\nndvi_dl <- ee_image_to_drive(\n  image = ndvi_lc,\n  description = \"NDVI_LC_2021\",\n  folder = \"SII_Export\",\n  fileFormat = \"GEO_TIFF\",\n  crs='EPSG:4326', \n  region = region,\n  scale = 30\n)\nndvi_dl$start()\nee_monitoring(ndvi_dl)\nndvi_dl$status()$state\n\nif(ndvi_dl$status()$state==\"COMPLETED\"){\n  img <- ee_drive_to_local(\n    task = ndvi_dl,\n    metadata = TRUE,\n    dsn = \"data/raster/dl_ndvi_lc_2021.tif\"\n  )\n}\n\nVisualización de NDVI Las Condes\n\nndvi <- raster(\"data/raster/dl_ndvi_lc_2021.tif\")\nhist(ndvi,col=\"springgreen4\", main=\"Histograma NDVI Las Condes\",\n  ylab=\"Numero de Pixeles\", xlab=\"valor NDVI\")\n\n\n\nplot(ndvi)\n\n\n\n\n\n\n5.10.2 Filtrar Vegetación Alta\nFunción de filtro por valor\n\nfn_gte <- function(value) {\n  function(x){ifelse(x >= value,x, NA)}\n}\n\nAsumiremos que nuestro valor de NDVI que corresponde a vegetación alta es de mayor a 0.4\n\nvegetacion <- calc(ndvi, fun = fn_gte(value = 0.4))\n\n\n\n5.10.3 Visualización de Resultados\nVisualización estática\n\npal_green <-\n  colorRampPalette(c(\"green\", \"springgreen4\", \"darkgreen\"))(200)\n\n\nplot(vegetacion , main = \"NDVI Vegetación Alta\", col = pal_green)\n\n## agregar Las polígono de Las Condes\nplot(LasCondes$geometry, add = T)\n\n\n\n\nVersión Dinámica con Mapview\n\n# install.packages(\"mapview\")\nsuppressPackageStartupMessages(library(mapview))\n\nmview <- mapview(LasCondes, color = \"#05A39B\", alpha.region =0)+\n  mapview(vegetacion, na.color = \"transparent\") +\n  mapview(ndvi, na.color = \"transparent\", hide =TRUE) \n\n  \nmview\n\n\n\n\n\n# Mostrar opciones de guardar resultados dinámicos\n\nVersión Dinámica con leaflet\n\nlibrary(leaflet)\npal <- colorNumeric(c(\"green\",\"springgreen4\", \"darkgreen\"), values(vegetacion), na.color = \"transparent\")\n\nmap <- leaflet() %>% \n  addTiles(group = \"OSM (default)\") %>%  \n  addProviderTiles(providers$Stamen.Toner, group = \"Toner\") %>%\n  addProviderTiles(providers$Stamen.TonerLite, group = \"Toner Lite\") %>%\n  addProviderTiles(providers$Esri.WorldImagery, group = \"Satellite\")%>%\n  addRasterImage(vegetacion,  colors = pal, opacity = 1, group = \"Vegetación\") %>%\n  addLegend(position = \"bottomright\", pal = pal, values = values(vegetacion),\n            opacity = 1, group = \"Vegetación\", title = \"Vegetación\")%>%\n  addPolygons(data = LasCondes, color =  \"navy\",fillOpacity = 0, weight = 3)%>%\n  addLayersControl(position = \"topright\",\n                   baseGroups = c(\"Toner Lite\",\"Satellite\", \n                                  \"OSM (default)\", \"Toner\"),\n                   overlayGroups = \"Vegetación\",\n                   options = layersControlOptions(collapsed = TRUE))\nmap"
  },
  {
    "objectID": "intro_gee.html#referencias",
    "href": "intro_gee.html#referencias",
    "title": "5  S3: Introducción a GEE",
    "section": "5.11 Referencias",
    "text": "5.11 Referencias\n\nGithub Rgee\nEarth Engine with R (Book)\n\n\n\n\n\nAybar, Cesar, Quisheng Wu, Lesly Bautista, Roy Yali, and Antony Barja. 2020. “Rgee: An r Package for Interacting with Google Earth Engine.” Journal of Open Source Software.\n\n\nGorelick, Noel, Matt Hancher, Mike Dixon, Simon Ilyushchenko, David Thau, and Rebecca Moore. 2017. “Google Earth Engine: Planetary-Scale Geospatial Analysis for Everyone.” Remote Sensing of Environment 202: 18–27. https://doi.org/https://doi.org/10.1016/j.rse.2017.06.031."
  },
  {
    "objectID": "proc_gee.html#índice-de-diferencia-normalizada-de-agua-ndwi",
    "href": "proc_gee.html#índice-de-diferencia-normalizada-de-agua-ndwi",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.1 Índice de Diferencia Normalizada de Agua (NDWI)",
    "text": "6.1 Índice de Diferencia Normalizada de Agua (NDWI)\nEl índice de Diferencia Normalizada de Agua (NDWI) es un índice que se utiliza en percepción remota para identificar cuerpos de agua y humedad en la superficie de la tierra. Este índice es especialmente útil cuando se utiliza con imágenes satelitales de Landsat, ya que utiliza bandas espectrales específicas para detectar la presencia de agua.\n\n\n\nEjemplo de resultados de NDWI\n\n\nEl índice NDWI se calcula como (NIR - SWIR) / (NIR + SWIR), donde NIR es la banda del infrarrojo cercano y SWIR es la banda del infrarrojo de onda corta. La razón detrás de este cálculo es que el agua absorbe más radiación en la banda del infrarrojo cercano y refleja menos radiación en la banda del infrarrojo de onda corta, en comparación con otros objetos en la superficie terrestre. Por lo tanto, los cuerpos de agua y la humedad en la superficie de la tierra tendrán un valor NDWI más alto que otros objetos en la imagen.\nEl índice NDWI es especialmente útil para la detección de cuerpos de agua y humedad en áreas como los bosques y los cultivos, lo que puede ser importante para la comprensión de la salud del ecosistema y la evaluación de la disponibilidad de agua para los cultivos.\nDependiendo de la extensión del área de estudio o la disponibilidad de imágenes de calidad (que hayan pasado filtros), a veces es necesario construir un mosaico que es una combinación o fusión de dos o más imágenes.\n\n\n\nRepressentación Gráfica de un Mosaico"
  },
  {
    "objectID": "proc_gee.html#modelo-digital-de-elevación",
    "href": "proc_gee.html#modelo-digital-de-elevación",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.2 Modelo Digital de Elevación",
    "text": "6.2 Modelo Digital de Elevación\nUn Modelo Digital de Elevación (MDE) es un conjunto de datos que representa la elevación de la superficie terrestre en una región en particular. Los datos del MDE se utilizan comúnmente en percepción remota para la creación de mapas topográficos y la identificación de características geográficas, como montañas, valles y cuerpos de agua.\nLos MDE se crean mediante la recopilación de datos de elevación a través de diversas técnicas, como la fotogrametría, el LiDAR y la interferometría de radar. Los datos resultantes se procesan para crear un modelo tridimensional de la superficie terrestre que se puede utilizar para análisis y visualizaciones. Los MDE son una herramienta esencial en la percepción remota y se utilizan en una variedad de aplicaciones, desde la gestión de recursos naturales hasta la planificación urbana y la navegación.\n\nDSM:\n\nEl Modelo Digital de Superficie representa las elevaciones sobre el nivel del mar de las superficies reflectantes de árboles, edificios y otras características elevadas sobre la “Tierra desnuda”.\n\nAVE:\n\nElevation value calculated by average. Valor de elevación calculado mediante el re-muestreo promedio de un modelo de grilla de 5 metros.\n\nAspect:\n\nLa orientación puede pensarse como la dirección de la pendiente Slope (pendiente): La pendiente representa la inclinación de la superficie."
  },
  {
    "objectID": "proc_gee.html#información-climática",
    "href": "proc_gee.html#información-climática",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.3 Información Climática",
    "text": "6.3 Información Climática\n\n6.3.1 Precipitaciones\nTerraClimate is a dataset of monthly climate and climatic water balance for global terrestrial surfaces. University of California Merced.\n\nResolución Espacial: 2.5 arc minutes (1 arc min = 1,85 km) = 4625 metros\nResolución Temporal: 1 mes\nDisponible: 1958-01-01 - 2023-04-30\n\n\n\n6.3.2 Temperatura\nNCEP Climate Forecast System es un modelo totalmente acoplado que representa la interacción entre la atmósfera terrestre, los océanos, la tierra y el hielo marino. Desarrollado en el Environmental Modeling Center (EMC) en NCEP.\n\nResolución Espacial: 0.2 arc degrees (1 arc min = 1,85 km) = 22.2 Km\nResolución Temporal: 6 horas\nDisponible: 1979-01-01 - 2020-11-25\n\n\n\n\n\n\n\nCargar Librerías\n\nsuppressMessages(library(sf))\nsuppressMessages(library(rgee))\nee_Initialize('denis.berroeta@gmail.com', drive = TRUE)\n\n── rgee 1.1.5 ─────────────────────────────────────── earthengine-api 0.1.335 ── \n ✔ user: denis.berroeta@gmail.com \n ✔ Google Drive credentials:\n ✔ Google Drive credentials:  FOUND\n ✔ Initializing Google Earth Engine:\n ✔ Initializing Google Earth Engine:  DONE!\n\n ✔ Earth Engine account: users/denisberroeta \n──────────────────────────────────────────────────────────────────────────────── \n\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(ggplot2))\nsuppressMessages(library(viridis))"
  },
  {
    "objectID": "proc_gee.html#ndwi-en-valdivia",
    "href": "proc_gee.html#ndwi-en-valdivia",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.4 NDWI en Valdivia",
    "text": "6.4 NDWI en Valdivia\n\n\n\n\n\n\n6.4.1 Seleccionar escena de Valdivia\n\ncoord_valdivia <- c(-73.225, -39.828)\nimagen <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$\n  filterBounds(ee$Geometry$Point(coords = coord_valdivia))$\n  filterDate('2021-01-01','2021-07-01')$\n  filterMetadata('CLOUD_COVER','less_than', 5)$\n  median()\n\n\n\n6.4.2 Visualización Imagen Satelital en Falso Color\n\n\n\n\n\n\nimgViz <- list(min = 0, max = 0.5,  bands = c(\"B5\", \"B4\", \"B3\"), gamma = c(0.95, 1.1, 1))\nMap$setCenter(-73.225, -39.828, 12)\nMap$addLayer(imagen, imgViz,'Landsat 8 Image')\n\n\n\n\n\n\n\n6.4.3 Calcular NDWI (Normalized Difference Water Index)\n\n\n\n\n\n\nndwi <- imagen$normalizedDifference(c(\"B3\", \"B5\")) # Considerar esta otra forma calcular indices normalizados\n\nndwiViz <- list(min = 0, max = 1, palette = c(\"00FFFF\",'0080FF', \"0000FF\"))\nMap$setCenter(-73.225, -39.828, 12)\nMap$addLayer(ndwi, ndwiViz,'NDWI')\n\n\n\n\n\n\n\n6.4.4 Crear Mácara por umbral\n\nndwiMask <- ndwi$updateMask(ndwi$gte(0.15)) # similar a los umbrales de NDVI para estimar vegetación\nMap$addLayer(ndwiMask, ndwiViz,'Máscara NDWI')\n\n\n\n\n\n\n\n6.4.5 Crear Mosaico\n\n\n\n\n\n\nimageRGB <- imagen$visualize(bands = c('B5', 'B4', 'B3'), max = 0.5, gamma = c(0.95, 1.1, 1))\nndwiRGB <- ndwiMask$visualize(min = 0.2, max = 1, palette = c('#00FFFF', '#0000FF'))\nmosaic <- ee$ImageCollection(c(imageRGB, ndwiRGB))$mosaic() # función crea mosaico\nMap$setCenter(-73.225, -39.828, 11)\nMap$addLayer(mosaic , list(), 'mosaic') # \n\n\n\n\n\n\n\n6.4.6 Generar Área de estudio circular\n\nroi <- ee$Geometry$Point(c(-73.225, -39.828))$buffer(10000)\nm <- Map$setCenter(-73.225, -39.828, 11)\nm <- Map$addLayer(mosaic$clip(roi))\nm #"
  },
  {
    "objectID": "proc_gee.html#modelo-digital-de-elevación-ejemplo-con-volcanes",
    "href": "proc_gee.html#modelo-digital-de-elevación-ejemplo-con-volcanes",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.5 Modelo Digital de Elevación Ejemplo con Volcanes",
    "text": "6.5 Modelo Digital de Elevación Ejemplo con Volcanes\n\n\n\n\n\n\nLista de volcanes de Chile Wikipedia\n\nInformación de Volcanes de Chile https://www.volcanesdechile.net\n\n\n6.5.1 Definir Área de Estudio\n\ncoods_volcan <- rev(c(-41.1, -72.493056)) # v osorno\n# coods_volcan <- rev(c(-20.933333, -68.483333))     # v elección\nvolcan_p_ee <- ee$Geometry$Point(coords = coods_volcan)\nregion <- volcan_p_ee$bounds()$buffer(10000)\n\n\n\n6.5.2 Parámetros de Visulización\n\nviz_gray <- list(palette = colorRampPalette(c(\"gray90\",\"gray20\"))( 100 ))\n\n\nviz_pal1 <-\n  list(\n    palette = c(\n      '3ae237',\n      'b5e22e',\n      'd6e21f',\n      'fff705',\n      'ffd611',\n      'ffb613',\n      'ff8b13',\n      'ff6e08',\n      'ff500d',\n      'ff0000',\n      'de0101',\n      'c21301',\n      '0602ff',\n      '235cb1',\n      '307ef3',\n      '269db1',\n      '30c8e2',\n      '32d3ef',\n      '3be285',\n      '3ff38f',\n      '86e26f'\n    ),\n    min = 0.0,\n    max = 360.0\n  )\n\n\nviz_pal2 <-\n  list(\n    palette = c(\n      '0602ff',\n      '235cb1',\n      '307ef3',\n      '269db1',\n      '30c8e2',\n      '32d3ef',\n      '3ae237',\n      'b5e22e',\n      'd6e21f',\n      'fff705',\n      'ffd611',\n      'ffb613',\n      'ff8b13',\n      'ff6e08',\n      'ff500d',\n      'ff0000',\n      'de0101',\n      'c21301'\n    ),\n    min = 0,\n    max = 8859.0\n  )\n\n\n\n6.5.3 Objetos de Elevación\n\nDEM <- ee$Image(\"JAXA/ALOS/AW3D30/V2_2\")$clip(region) # cortar por región de estudio\n# ee_print(DEM) #visualizar atributos de objeto gee DEM\nDSM <- DEM$select('AVE_DSM');\naspect <-  ee$Terrain$aspect(DEM)\nslope <-  ee$Terrain$slope(DEM)\n\n\n\n6.5.4 Visualización\n\nMap$centerObject(region, zoom = 11) \nMap$addLayer(eeObject = slope, visParams = viz_gray, name = \"Slope\") + \nMap$addLayer(eeObject = DSM, visParams = viz_pal2, name = \"DSM\",  opacity = 1) +\nMap$addLayer(eeObject = aspect, visParams = viz_pal1,name =  \"aspect\", opacity = 0.5, shown = FALSE)"
  },
  {
    "objectID": "proc_gee.html#datos-climáticos",
    "href": "proc_gee.html#datos-climáticos",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.6 Datos Climáticos",
    "text": "6.6 Datos Climáticos\n\n6.6.1 Estadística Zonal de precipitación Precipitación con Imágenes Satelitales\nTerraClimate: Monthly Climate and Climatic Water Balance for Global Terrestrial Surfaces, University of Idaho\n\n\n6.6.2 Extraer Valores de Precipitación Anual Mundial\n\nterraclimate <- ee$ImageCollection(\"IDAHO_EPSCOR/TERRACLIMATE\")$\n  filterDate(\"2019-01-01\", \"2020-01-01\")$\n  select(\"pr\")$\n  median()\n\nvisParams = list(min = 0, max = 100, palette = c('#00FFFF', '#0000FF'))\n\nMap$setCenter(-60, -21, 3)\nMap$addLayer(terraclimate, visParams, 'Prec (mm)')\n\n\n\n\n\n\n\n6.6.3 Precipitación Anual 2019 RM\n\n\n\n\n\n\n# Leeer Shape RM\nrm <- st_read(\"data/shape/Reg_Met.shp\") %>% \n  st_transform(\"+proj=longlat +datum=WGS84 +no_defs\")\n\nReading layer `Reg_Met' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII/data/shape/Reg_Met.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -71.71523 ymin: -34.29093 xmax: -69.76999 ymax: -32.92194\nGeodetic CRS:  WGS 84\n\nrm_ee <-  rm%>%\n  st_geometry() %>% ## Solamente me quedo con la geometría (descarto la data)\n  sf_as_ee()\n\n\nterraclimate <- ee$ImageCollection(\"IDAHO_EPSCOR/TERRACLIMATE\")$\n  filterDate(\"2017-01-01\", \"2018-01-01\")$\n  map(function(x){\n    date <- ee$Date(x$get(\"system:time_start\"))$format('YYYY_MM_dd')\n    name <- ee$String$cat(\"Terraclimate_pp_\", date)\n    x$select(\"pr\")$reproject(\"EPSG:4326\")$set(\"RGEE_NAME\", name)\n  })\n\n#proceso clave de extracción de datos satelitales y los lleva a tabla\nee_rm_rain <- ee_extract(x = terraclimate, y = rm_ee, sf = FALSE )\n\nNumber of features: Calculating ...\nNumber of features: 1                     \n\ncolnames(ee_rm_rain) <- sprintf(\"%02d\", 1:12)\n\nhead(ee_rm_rain)\n\n        01       02       03      04       05       06       07      08\n1 2.171239 17.05393 9.221501 35.6614 88.79629 80.26654 29.29532 61.9945\n        09       10       11       12\n1 24.55665 47.34377 12.31215 4.403785\n\npr_data <- ee_rm_rain %>%\n  pivot_longer(cols = 01:12, names_to = \"month\", values_to = \"pr\")\n\nggplot(data = pr_data, aes(x = month, y = pr, color = pr, group=1)) +\n  geom_point(size = 4) +\n  scale_color_viridis()+\n  geom_line(alpha = 0.4, color = \"gray50\") +\n    ggtitle(lab = \"Precipitaciones: IDAHO_EPSCOR/TERRACLIMATE\", \n          subtitle = \"Región Metropolitana\") +\n  xlab(\"Month\") +\n  ylab(\"Precipitation (mm)\") +\n  theme_minimal()\n\n\n\n\n\n\n6.6.4 Estadísticas Zonal de Temperatura\nCFSV2: NCEP Climate Forecast System Version 2, 6-Hourly Products\n\n# https://developers.google.com/earth-engine/datasets/catalog/NOAA_CFSV2_FOR6H#description\ndataset <- ee$ImageCollection('NOAA/CFSV2/FOR6H')$\n  filter(ee$Filter$date('2019-01-01', '2020-01-01'))$\n  median()\n\ntemperatureAboveGround = dataset$select('Temperature_height_above_ground')\nvisParams = list(min= 220.0,  max = 310.0, \n                 palette = colorRampPalette(c('blue', 'purple', 'cyan', 'green', 'yellow', 'red'))( 10 ))\nMap$setCenter(-60, -21, 3)\nMap$addLayer(temperatureAboveGround, visParams, 'Temp. Ground')\n\n\n6.6.4.1 Temperatura RM 4 veces al día\n\n\n\n\n\n“Alarmante estimación proyecta que cordillera de los Andes se quedaría sin nieve y los ríos de la zona central se podrían secar en un plazo de 40 años”: Diario La Tercera 22-ABR-2021\n\ntemp <- ee$ImageCollection('NOAA/CFSV2/FOR6H')$\n  filterDate('2019-01-01', '2019-04-01')$\n  map(function(x){\n    date <- ee$Date(x$get(\"system:time_start\"))$format('YYYY_MM_dd')\n    name <- ee$String$cat(\"temp_\", date)\n    x$select(\"Temperature_height_above_ground\")$set(\"RGEE_NAME\", name)\n  })\n\nee_rm_temp <- ee_extract(x = temp, y = rm_ee, sf = FALSE )\n\nNumber of features: Calculating ...\nNumber of features: 1                     \n\n#función para generar vector de días \nmake_rep <- function(min, max, n_rep = 4){\n  vec <- NULL\n  for(i in min:(max/n_rep)){\n    num <- rep(i, n_rep)\n    vec <- c(vec, as.integer(num))}\n  return(vec)\n}\n\n\ndias <- make_rep(min = 1, max = length(ee_rm_temp), n_rep = 4)\n\n\ntemp_data <- ee_rm_temp %>%\n  pivot_longer(cols = 1:length(ee_rm_temp), names_to = \"dia_total\", values_to = \"temp\")%>%\n  mutate(dia = dias, gr_celcius = as.numeric(temp) -273.15 )%>%\n  group_by(dia)%>%\n  summarise(temp_prom = mean(gr_celcius),.groups = \"keep\" )%>%\n  as.data.frame()\n  \n\nggplot(data = temp_data, aes(x = dia, y = temp_prom, color = temp_prom)) +\n  geom_point() +\n  geom_line(alpha = 0.4) +\n  scale_color_viridis(option=\"magma\")+\n  ggtitle(lab = \"Temperatura: NOAA/CFSV2/FOR6H\", \n          subtitle = \"Región Metropolitana\") +\n  xlab(\"Día\") +\n  ylab(\"Temperatura\") +\n  theme_minimal()\n\n\n\n\n\n\n6.6.4.2 Temperatura Las Condes 4 veces al día\n\nLC_ee <- st_read(\"data/shape/LasCondes.shp\") %>% \n  st_transform(\"+proj=longlat +datum=WGS84 +no_defs\")%>%\n  st_geometry() %>% # solo quedarse con la geometría\n  sf_as_ee()\n\nReading layer `LasCondes' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII/data/shape/LasCondes.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 350513.9 ymin: 6293910 xmax: 367354.6 ymax: 6307356\nProjected CRS: WGS 84 / UTM zone 19S\n\nee_lc_temp <- ee_extract(x = temp, y = LC_ee, sf = FALSE) \n\nNumber of features: Calculating ...\nNumber of features: 1                     \n\n# Extrae los valores por un promedio por cada geometría\n # fun = ee$Reducer$mean()\n\ndias <- make_rep(min = 1, max = length(ee_lc_temp), n_rep = 4)\n\ntemp_data <- ee_lc_temp %>%\n  pivot_longer(cols = 1:length(ee_rm_temp), names_to = \"dia_total\", values_to = \"temp\")%>%\n  mutate(dia = dias, gr_celcius = as.numeric(temp) -273.15 )%>%\n  group_by(dia)%>%\n  summarise(temp_prom = mean(gr_celcius),.groups = \"keep\" )%>%\n  as.data.frame()\n  \n\nggplot(data = temp_data, aes(x = dia, y = temp_prom, color = temp_prom)) +\n  geom_point() +\n  geom_line(alpha = 0.4) +\n  scale_color_viridis(option=\"magma\")+\n  ggtitle(lab = \"Temperatura: NOAA/CFSV2/FOR6H\", \n          subtitle = \"Comuna de Las Condes\") +\n  xlab(\"Día\") +\n  ylab(\"Temperatura\") +\n  theme_minimal()"
  },
  {
    "objectID": "proc_gee.html#referencias",
    "href": "proc_gee.html#referencias",
    "title": "6  S4: Procesamiento con GEE desde R",
    "section": "6.7 Referencias",
    "text": "6.7 Referencias\nGoogle Earth Engine for R https://github.com/r-spatial/rgee\nEjemplos https://csaybar.github.io/rgee-examples/"
  },
  {
    "objectID": "tarea_1.html#antecedentes",
    "href": "tarea_1.html#antecedentes",
    "title": "Tarea 1",
    "section": "Antecedentes",
    "text": "Antecedentes\nFecha de Entrega: 08 de Mayo del 2023\nFormato de Entrega: Documento de texto (word, pdf, markdown) + códigos (.R)\nIntegrantes: 2 Personas"
  },
  {
    "objectID": "tarea_1.html#enuncuciado",
    "href": "tarea_1.html#enuncuciado",
    "title": "Tarea 1",
    "section": "Enuncuciado",
    "text": "Enuncuciado\n\nCrear un raster de ncol = 500, nrow = 500, projection = crs_utm (objeto creado anteriormente), valores aleatorios y plot. (2 puntos).\n\n\n\n\n\n\n\nTip: Section 3.3\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia pero con la raiz cuadrada de los valores originales, y si existe un valor de pixel mayor a 35 debe ser cambiado por 35, finalmente plot (2 Puntos).\n\n\n\n\n\n\n\nTip: Section 3.3.2\n\n\n\n\n\n\n\n\nDesde el raster “r_test”, crear una copia y reclasificar todos sus valores, de 0 a 500 valor 1, 501 a 1000 valor 2, 1001 a 1500 valor 3, mayor a 1500 será 4, finalmente plot (2 puntos). (Hint: )\n\n\n\n\n\n\n\nTip: Section 3.3.3"
  },
  {
    "objectID": "tarea_1.html#adicional",
    "href": "tarea_1.html#adicional",
    "title": "Tarea 1",
    "section": "Adicional",
    "text": "Adicional\nSe les recuerda seguir el manual de instalación del librería rgee que se encuentra en el siguiente anexo Appendix G"
  },
  {
    "objectID": "tarea_1.html#referencias",
    "href": "tarea_1.html#referencias",
    "title": "Tarea 1",
    "section": "Referencias",
    "text": "Referencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias Bibliográficas",
    "section": "",
    "text": "Aybar, Cesar, Quisheng Wu, Lesly Bautista, Roy Yali, and Antony Barja.\n2020. “Rgee: An r Package for Interacting with Google Earth\nEngine.” Journal of Open Source Software.\n\n\nGorelick, Noel, Matt Hancher, Mike Dixon, Simon Ilyushchenko, David\nThau, and Rebecca Moore. 2017. “Google Earth Engine:\nPlanetary-Scale Geospatial Analysis for Everyone.” Remote\nSensing of Environment 202: 18–27. https://doi.org/https://doi.org/10.1016/j.rse.2017.06.031."
  },
  {
    "objectID": "intro_R.html#qué-es-r-project",
    "href": "intro_R.html#qué-es-r-project",
    "title": "Appendix A — Introducción a R",
    "section": "A.1 ¿Qué es R Project?",
    "text": "A.1 ¿Qué es R Project?\nR es un lenguaje programación multiparadigma (procedural, imperativo, orientado a objetos y funcional) enfocado a aplicaciones estadísticas. Por estadísticas se debe entender también los campos de estudio que se basan o las utilizan como económía, finanzas, ciencia de datos, machine learning, etc.\n\nA.1.1 Ventajas de Utilizar R Project\n1. R es un software libre\n\nLa libertad de ejecutar el programa como desee y con cualquier propósito\nEstudiar el funcionamiento del programa y adaptarlo a sus necesidades.\nRescribir copias para ayudar a los demás.\nManejar el programa y publicar las mejorar, de manera que toda comunidad se beneficie.\n\n2. R es multiplataforma\n\nR funciona en Mac, Windows y en numerosos sistemas UNIX. Esto significa que cualquier persona puede trabajar con tus datos, figuras, análisis y más importante aún usar tus instrucciones (también conocido como scripts o código) para generar las figuras y el análisis. Así que cualquier persona, y en cualquier lugar del mundo, con acceso a cualquier SO puede usar R sin ninguna licencia.\n\n3. R es de código abierto\n\nExiste una gran comunidad de voluntarios trabajando para mejorarlo, lo cual permite ser moldeado y dirigido a cuestiones específicas. Creando así programas y paquetes que funcionen en el entorno R. Programas tales como R-studio, Java GUI for R, R- commander, RKWard, entre otros, y con más de 18000 paquetes indexado en CRAN, Biocoductor, GitHub y R-Forge.\n\n4. Todo dentro de un mismo entorno\n\nR remplaza la combinación de varios programas para el proceso de análisis de datos, por ejemplo Excel, ArcGis, QGis, SigmaPlot, entre otros. Esto no solo resulta en el alto costo de las licencias de múltiples programas, si no también, en la gran cantidad de archivos con diferentes formatos que no podrían leer otros programas. En cambio con solo utilizar R, puedes realizar todo el análisis de datos e inclusive leer archivos de diferentes formatos.\n\n\n\nA.1.2 Desventajas de utilizar R\n\nR tiene una vasta documentación de ayuda, descripción de paquetes y de funciones, que es difícil encontrar información específica en un momento dado.\nLos mensajes de error que R nos muestra, no es específica sobre los fallos que estamos realizando y solo un usuario con cierta experiencia en el uso de R puede saberlo."
  },
  {
    "objectID": "intro_R.html#instalación-de-r-project",
    "href": "intro_R.html#instalación-de-r-project",
    "title": "Appendix A — Introducción a R",
    "section": "A.2 Instalación de R Project",
    "text": "A.2 Instalación de R Project\n\nA.2.1 Instalación de R Project\nPrimero se debe instalar R Project desde su sitio oficial (https://cran.r-project.org/bin/windows/base/), se ejecuta el instalador que se descargó depende del sistema operativo del PC, como se muestra en las siguientes figuras:\n\n\n\nA.2.2 Instalación de R para Windows\n\n\n\n\n\nA.2.3 Instalar Rtools (solo Sistema Operativo Windows)\n\n\n\n\n\n\n\n\nA.2.4 Instalación de R para Mac\n\n\n\nR Project Ejecutándose"
  },
  {
    "objectID": "intro_R.html#instalación-de-rstudio",
    "href": "intro_R.html#instalación-de-rstudio",
    "title": "Appendix A — Introducción a R",
    "section": "A.3 Instalación de RStudio",
    "text": "A.3 Instalación de RStudio\nSe recomienta instalar Rstudio, que es Interfaz de Usuario de R Project, desde su sitio web oficial, el cual permite acceder con mayor facilidad a sus funciones y potencialidades de R.\n\n\n\n\n\n\n\n\n\nA.3.1 RStudio Cloud\nRStudio Cloud es una versión ligera del IDE RStudio alojada en la la nube que permite a cualquiera hacer, compartir, enseñar y aprender Ciencias de Datos Online. Tiene una versión gratuita limitada.\n\nA.3.1.1 Características:\n\nAnalyze your data using the RStudio IDE, directly from your browser.\nShare projects with your team, class, workshop or the world.\nTeach data science with R to your students or colleagues.\nLearn data science in an instructor-led environment or with interactive tutorials."
  },
  {
    "objectID": "intro_R.html#instalar-librerías",
    "href": "intro_R.html#instalar-librerías",
    "title": "Appendix A — Introducción a R",
    "section": "A.4 Instalar Librerías",
    "text": "A.4 Instalar Librerías\n\nA.4.1 Librerías en R\nLas librerías o paquetes en R corresponden a una colección de funciones encapsuladas y diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, mineria de datos, interacción con servicios de internet y muchas otras cosas más.\nEstos paquetes se encuentran alojados principalmente en CRAN (Comprehensive R Archive Network), así que pasan por un control riguroso antes de estar disponibles para su uso generalizado, al día de hoy (29.11.2021) existen 18498 paquetes disponibles. En el siguiente enlace se deja una lista de temas y sus librerías asociadas disponibles, con una breve descripción (enlace)\nAunque las versiones de prueba de una librería pueden estar disponible en Github (Respositorio de Control de Versiones) de cada autor.\n\n\nA.4.2 Ejemplo de Instalación de Librerías desde R\nPodemos instalar paquetes usando la función install.packages(), dando como argumento el nombre del paquete que deseamos instalar, entre comillas.\nPara instalar librerías se puede hacer directamente desde la consola de RStudio, por ejemplo:\n\ninstall.packages(\"dplyr\") # Se puede instalar más de una librería a la vez\n\n\n\nA.4.3 Ejemplo de Instalación de Librerías desde Rstudio\nTambién se pude instalar librerías del Panel “Packages”\n\n\n\nY por último se puede instalar desde Pestaña “Tools” -> “Install Packages”:"
  },
  {
    "objectID": "intro_R.html#definición-de-directorios-de-trabajos",
    "href": "intro_R.html#definición-de-directorios-de-trabajos",
    "title": "Appendix A — Introducción a R",
    "section": "A.5 Definición de Directorios de Trabajos",
    "text": "A.5 Definición de Directorios de Trabajos\nDefinir directorio de Trabajo con RStudio\n\n\n\n\n\n\nDefinir Directorio de Trabajo con una función\n\nsetwd(\"~/OneDrive - Universidad Adolfo Ibanez/CIT/DOCENCIA/CLASES_SII/\")\n\nConsultar Directorio de Trabajo\n\ngetwd()\n\n[1] \"/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/CIT/DOCENCIA/CURSO_SII_PR/book_PR_SII\""
  },
  {
    "objectID": "variables_R.html#tipos-de-objetos-en-r",
    "href": "variables_R.html#tipos-de-objetos-en-r",
    "title": "Appendix B — Variables en R",
    "section": "B.1 Tipos de Objetos en R",
    "text": "B.1 Tipos de Objetos en R\nLos Datos en R se pueden clasificar por su dimensiones y los tipos de Datos que permiten almacenar, como se muestra en la siguiente tabla:\n\n\n\nDimensiones\nHomogéneos\nHeterogéneos\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\nFuente: http://adv-r.had.co.nz/Data-structures.html\nR nos permite definir variables que pueden ser luego usadas en las distintas operaciones. El lenguaje no solo permite definir escalares (variable de un numero), si no también variables que sean un conjunto de numero o caracteres ordenados.\n\nB.1.1 Variables Numéricas\n\n# La asignación en R son válidos 2 métodos '<-' o '='\nx <- 7 # Definir variable (escalar) x que sea igual a 7\nx # Mostrar que es x\n\n[1] 7\n\ny <- 3 + 2 * x # Crear y como funcion de x \ny\n\n[1] 17\n\nclass(y)\n\n[1] \"numeric\"\n\n\nNúmeros Random con decimales\n\nru <- runif(n = 100, min = 1, max = 10)\nru\n\n  [1] 7.551209 2.334812 3.612820 8.382537 1.761468 2.794304 9.249893 2.175162\n  [9] 6.600906 1.715667 8.353443 8.912974 4.610222 3.871824 2.939277 4.295799\n [17] 2.477778 7.607139 7.632074 4.871414 6.310153 6.189983 6.511036 1.877842\n [25] 6.810810 3.218878 9.899734 7.898439 5.008999 4.452679 4.143839 3.216791\n [33] 1.885492 1.720362 5.215545 9.584168 7.234635 6.414720 4.576278 6.561206\n [41] 8.612455 3.650364 7.161058 7.774897 9.125724 2.082748 7.164539 7.509014\n [49] 1.372458 4.423964 5.837095 7.357098 3.362840 7.820621 9.297707 1.170155\n [57] 9.125317 3.729360 8.661690 4.862742 4.160440 9.570894 6.235626 7.214249\n [65] 1.882570 4.390272 5.444010 9.160566 3.005224 4.526701 7.664012 4.083133\n [73] 3.790222 3.053187 7.374162 3.277861 8.143648 7.888002 3.045430 4.977148\n [81] 7.481989 3.531315 2.623629 7.188369 9.633126 7.503752 5.103258 5.033466\n [89] 8.613206 5.498404 2.977977 7.527599 2.173729 5.277206 9.356208 5.278450\n [97] 3.268543 2.894736 6.629041 9.654346\n\n\n\nhist(ru, breaks = 20, col = \"orange\", border = \"gray60\", \n     main = \"Histograma de valores Random\")\n\n\n\n\n\n\n\n\nNúmeros Random Enteros\nSimular los lanzamientos de un dado\n\nsample.int(n = 6, size = 10, replace = T)\n\n [1] 6 3 3 2 3 6 2 5 2 2\n\n\n\n\nB.1.2 Variables de Caracter\n\nch <- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn <- \"Santiago\"\nch # Mostrar ch\n\n[1] \"Chile\"\n\nsn\n\n[1] \"Santiago\"\n\n\nUnir variables de texto con paste()\n\nch <- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn <- \"Santiago\"\nunion <- paste(sn,ch, sep = \", \")\nunion\n\n[1] \"Santiago, Chile\"\n\n\nUtilizar paste0()\n\nunion <- paste(\"Provincia de \", sn,ch, sep = \", \")\nunion\n\n[1] \"Provincia de , Santiago, Chile\"\n\nunion0 <- paste0(\"Provincia de \", sn, \", \", ch)\nunion0\n\n[1] \"Provincia de Santiago, Chile\"\n\n\nBuscar y reemplazar con gsub\n\nav <- \"Av. Apoquindo\"\ncomuna <- \"comuna de Las Condes\"\ncalle <- paste(av, comuna, union0, sep = \", \")\ncalle\n\n[1] \"Av. Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\"\n\n# reemplazar Av. por Avenida\ncalle_new <- gsub(pattern = \"Av.\", replacement = \"Avenida\", x = calle)\ncalle_new\n\n[1] \"Avenida Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\""
  },
  {
    "objectID": "variables_R.html#estructuras-de-datos",
    "href": "variables_R.html#estructuras-de-datos",
    "title": "Appendix B — Variables en R",
    "section": "B.2 Estructuras de Datos",
    "text": "B.2 Estructuras de Datos\nLas variables pueden ser un conjunto de números y caracteres ordenados de varias maneras. El orden que se les da depende de lo que queremos lograr con estos.\n\nVector\nMatrices\nDataframes\nFactores\nListas\n\n\nB.2.1 Vectores\nVector Cadenas unidimensionales (es decir una sola columna o fila) de un tipo único de valores (numéricos, caracteres, etc.)\n\nvec <-  c(4, 3, 1, 5, 8, 16)\nvec\n\n[1]  4  3  1  5  8 16\n\nclass(vec)\n\n[1] \"numeric\"\n\nstr(vec)\n\n num [1:6] 4 3 1 5 8 16\n\n\nPodemos seleccionar parte del vector:\n\n# EL primer índice en R es 1 (en otros lenguajes de programación es 0)\nvec[3]\n\n[1] 1\n\n\nLa selección también puede ser hecha con una condición, de tal manera que solo seleccione aquella parte del vector que cumple con la condición.\nMayor a:\n\nvec[vec >= 4]\n\n[1]  4  5  8 16\n\n\nContenido en:\n\nvec[vec %in% c(3, 8, 7, 29)]\n\n[1] 3 8\n\n\nNegación de la condición:\n\nvec[!vec <= 3]\n\n[1]  4  5  8 16\n\n\nTambién podemos realizar operaciones matemáticas simples aplicadas al vector, por ejemplo una suma:\n\nvec2  <-  c(7, 10, 1)\nvec + vec2\n\n[1] 11 13  2 12 18 17\n\n\n\n\nB.2.2 Listas\nSon estructuras eficientes y flexibles, que permiten combinar distintas clases de elementos :\n\nlista <-  list(1, 2, 3, \"cosa\", x, y)\nlista\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"cosa\"\n\n[[5]]\n[1] 7\n\n[[6]]\n[1] 17\n\nstr(lista)\n\nList of 6\n $ : num 1\n $ : num 2\n $ : num 3\n $ : chr \"cosa\"\n $ : num 7\n $ : num 17\n\n\n\n#Tambien se puede seleccionar parte de una lista, usando el doble corchete:\nlista[[3]]\n\n[1] 3\n\n\nComo inspeccionar una lista con Rstudio\n\n\n\n\n\nB.2.3 Matrices\nSon estructuras de datos con 2 dimensiones, horizontal y la vertical (filas y columnas). Podemos construirlas usando la función “matrix”, con un vector inicial y sus dimensiones:\n\nn <- matrix(c(1.3, 2.8, 3.5, 6.4, 5.3, 6.2, 7, 4.5, 2.4, 6.3, 5.6, 5.3, 6.6, 7, 4.3),\n  nrow = 5, ncol = 3, byrow = TRUE)\nn\n\n     [,1] [,2] [,3]\n[1,]  1.3  2.8  3.5\n[2,]  6.4  5.3  6.2\n[3,]  7.0  4.5  2.4\n[4,]  6.3  5.6  5.3\n[5,]  6.6  7.0  4.3\n\n\nLa matriz tiene 2 dimensiones, por lo que para seleccionar partes de ella es necesario declarar dos dimensiones separadas por una coma. A la izquierda van las filas y a la derecha las columnas. Un valor vacío indica que se seleccionan todos los valores posibles.\n\nn[1,2]\n\n[1] 2.8\n\n\n\nn[,3]\n\n[1] 3.5 6.2 2.4 5.3 4.3\n\n\n\n\nB.2.4 Dataframes\nEstructura mas clásica de datos, es una matriz pero con mas atributos como nombres de columna y/o fila. Es lo mas similar en R a una tabla excel o la tabla de atributos. La manera mas simple de crear un dataframe es a partir de una matriz usando la función as.data.frame() :\n\ndf<- as.data.frame(n)\ndf\n\n   V1  V2  V3\n1 1.3 2.8 3.5\n2 6.4 5.3 6.2\n3 7.0 4.5 2.4\n4 6.3 5.6 5.3\n5 6.6 7.0 4.3\n\n\nPodemos asignar nombres a las columnas del dataframe\n\nnames(df)<- c(\"control_1\",\"control_2\",\"examen\")\ndf\n\n  control_1 control_2 examen\n1       1.3       2.8    3.5\n2       6.4       5.3    6.2\n3       7.0       4.5    2.4\n4       6.3       5.6    5.3\n5       6.6       7.0    4.3\n\n\nY a las filas del dataframe\n\ndf$alumno <- c(\"Sofia\",\"Tomas\",\"Luciano\",\"Julian\",\"Gabriela\")\ndf\n\n  control_1 control_2 examen   alumno\n1       1.3       2.8    3.5    Sofia\n2       6.4       5.3    6.2    Tomas\n3       7.0       4.5    2.4  Luciano\n4       6.3       5.6    5.3   Julian\n5       6.6       7.0    4.3 Gabriela\n\n\nTambién podemos realizar operaciones entre vectores del dataframe:\n\ndf$promedio_final <-  0.3*df$control_1 + 0.3*df$control_2 + 0.4*df$examen\ndf\n\n  control_1 control_2 examen   alumno promedio_final\n1       1.3       2.8    3.5    Sofia           2.63\n2       6.4       5.3    6.2    Tomas           5.99\n3       7.0       4.5    2.4  Luciano           4.41\n4       6.3       5.6    5.3   Julian           5.69\n5       6.6       7.0    4.3 Gabriela           5.80"
  },
  {
    "objectID": "funciones.html#operaciones-básicas-en-r",
    "href": "funciones.html#operaciones-básicas-en-r",
    "title": "Appendix C — Funciones en R",
    "section": "C.1 Operaciones Básicas en R",
    "text": "C.1 Operaciones Básicas en R\n\nC.1.1 Operaciones Matemáticas\nEn R, es posible realizar operaciones matemáticas básicas utilizando los operadores aritméticos estándar. Estos operadores incluyen:\n\nSuma (+): se utiliza para sumar dos valores.\nResta (-): se utiliza para restar un valor de otro.\nMultiplicación (*): se utiliza para multiplicar dos valores.\nDivisión (/): se utiliza para dividir un valor por otro.\nExponenciación (^): se utiliza para elevar un valor a una potencia.\nMódulo (%%): se utiliza para encontrar el resto de la división de un valor por otro.\n\nEstos operadores se pueden utilizar con números enteros, decimales y variables numéricas. Además, también se pueden utilizar paréntesis para especificar el orden de las operaciones.\nA continuación, se presentan algunos ejemplos de operaciones matemáticas básicas en R:\n\n# Suma\n2 + 3 # resultado: 5\n\n[1] 5\n\n# Resta\n5 - 2 # resultado: 3\n\n[1] 3\n\n# Multiplicación\n2 * 4 # resultado: 8\n\n[1] 8\n\n# División\n10 / 2 # resultado: 5\n\n[1] 5\n\n# Exponenciación\n2^3 # resultado: 8\n\n[1] 8\n\n# Módulo\n15 %% 4 # resultado: 3\n\n[1] 3\n\n# Utilizando paréntesis para especificar el orden de las operaciones\n(2 + 3) * 4 # resultado: 20\n\n[1] 20\n\n\nEs importante tener en cuenta que R sigue las reglas de precedencia de las operaciones matemáticas. Esto significa que las operaciones dentro de los paréntesis se evalúan primero, seguidas de la exponenciación, la multiplicación y la división, y finalmente la suma y la resta. Si se requiere un orden específico de operaciones, se deben utilizar paréntesis para indicarlo.\nAdemás, R también cuenta con una variedad de funciones matemáticas incorporadas, como “sin”, “cos”, “tan”, “log”, “exp”, entre otras, que se pueden utilizar para realizar operaciones más complejas.\nTambién se pueden aplica a un elemento a al objeto espacial completo\n\na <- 13\nb <- c(20,30,22,2,1)\n\nsum(b) # suma\n\n[1] 75\n\nsqrt(b) # find the square root of x\n\n[1] 4.472136 5.477226 4.690416 1.414214 1.000000\n\n\n\nmean(b)\n\n[1] 15\n\nmin(b)\n\n[1] 1\n\nmax(b)\n\n[1] 30\n\n\n\n\nC.1.2 Funciones Útiles de propósito general\n\nrep(1, 10)\n\n [1] 1 1 1 1 1 1 1 1 1 1\n\nrep(\"HAHA\", 10)\n\n [1] \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\" \"HAHA\"\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by = 2)\n\n[1] 1 3 5 7 9\n\nifelse(3 > 5, 1, \"this is false\")\n\n[1] \"this is false\"\n\n\n\npaste(\"Hola\", \"amigo\")\n\n[1] \"Hola amigo\"\n\npaste(\"Hello\", \"amigo\", sep = \"--\")\n\n[1] \"Hello--amigo\"\n\npaste0(\"Hello\", \"amigo\")\n\n[1] \"Helloamigo\"\n\ntolower(\"HAHAHAHAH\")\n\n[1] \"hahahahah\"\n\ntoupper(\"hueuehuehuheuhe\")\n\n[1] \"HUEUEHUEHUHEUHE\""
  },
  {
    "objectID": "funciones.html#operaciones-lógicas",
    "href": "funciones.html#operaciones-lógicas",
    "title": "Appendix C — Funciones en R",
    "section": "C.2 Operaciones Lógicas",
    "text": "C.2 Operaciones Lógicas\nEn R, los operadores lógicos se utilizan para realizar comparaciones lógicas entre valores o expresiones. Estos operadores devuelven valores booleanos (TRUE o FALSE) según se cumpla o no la condición.\nA continuación se presentan los operadores lógicos en R:\n\n\n\n\n \n  \n    Operador \n    Significado \n    Ejemplo \n  \n \n\n  \n    == \n    Igual a \n    2 == 2 (TRUE) \n  \n  \n    != \n    Diferente a \n    2 != 3 (TRUE) \n  \n  \n    > \n    Mayor que \n    3 > 2 (TRUE) \n  \n  \n    < \n    Menor que \n    2 < 3 (TRUE) \n  \n  \n    >= \n    Mayor o igual que \n    3 >= 2 (TRUE) \n  \n  \n    <= \n    Menor o igual que \n    2 <= 3 (TRUE) \n  \n  \n    & \n    Operador lógico AND \n    2 < 3 & 3 > 1 (TRUE) \n  \n  \n    | \n    Operador lógico OR \n    2 < 3 | 3 < 1 (TRUE) \n  \n  \n    ! \n    Operador lógico NOT \n    !(2 == 3) (TRUE) \n  \n\n\n\n\n\n\nC.2.1 Operador de igualdad: (==)\nEste operador se utiliza para comparar si dos valores son iguales. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\na == b # FALSE\n\n[1] FALSE\n\n\n\n\nC.2.2 Operador de desigualdad: (!=)\nEste operador se utiliza para comparar si dos valores son diferentes. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\na != b # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.3 Operador de mayor que: (>)\nEste operador se utiliza para comparar si un valor es mayor que otro. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\nb > a # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.4 Operador de menor que: (<)\nEste operador se utiliza para comparar si un valor es menor que otro. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\na < b # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.5 Operador de mayor o igual que: (>=)\nEste operador se utiliza para comparar si un valor es mayor o igual que otro. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\nb >= a # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.6 Operador de menor o igual que: (<=)\nEste operador se utiliza para comparar si un valor es menor o igual que otro. Retorna TRUE si la condición se cumple y FALSE en caso contrario.\n\na <- 2\nb <- 3\na <= b # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.7 Operador lógico AND: (&)\nEste operador se utiliza para evaluar dos o más condiciones y retornar TRUE si todas se cumplen, de lo contrario retorna FALSE.\n\na <- 2\nb <- 3\nc <- 4\na < b & b < c # TRUE\n\n[1] TRUE\n\n\n\n\nC.2.8 Operador lógico OR: (|)\nEste operador se utiliza para evaluar dos o más condiciones y retornar TRUE si al menos una se cumple, de lo contrario retorna FALSE.\n\na <- 2\nb <- 3\nc <- 4\na > b | b < c # TRUE\n\n[1] TRUE\n\n\nOperador lógico NOT: (!) Este operador se utiliza para negar una condición. Si la condición es TRUE, retorna FALSE, y si la condición es FALSE, retorna TRUE.\n\na <- 2\nb <- 3\n!(a == b) # TRUE\n\n[1] TRUE\n\n\nEs importante tener en cuenta que los operadores lógicos se pueden utilizar en combinación para crear expresiones lógicas más complejas. Además, los operadores lógicos también se pueden utilizar en las estructuras de control condicionales, como if/else y switch, para tomar decisiones basadas en condiciones lógicas."
  },
  {
    "objectID": "funciones.html#crear-funciones-propias",
    "href": "funciones.html#crear-funciones-propias",
    "title": "Appendix C — Funciones en R",
    "section": "C.3 Crear Funciones Propias",
    "text": "C.3 Crear Funciones Propias\nEn R, es posible crear funciones propias para realizar tareas específicas y reutilizarlas en diferentes partes de un programa. Para crear una función en R, se utiliza la siguiente estructura:\n\nnombre_de_la_funcion <- function(argumentos) {\n  cuerpo_de_la_funcion\n}\n\nPor ejemplo, se puede crear una función que calcule la suma de dos números:\n\nsuma <- function(a, b) {\n  resultado <- a + b\n  return(resultado)\n}\n\nresultado_suma <- suma(2, 3)\nprint(resultado_suma) # 5\n\n[1] 5\n\n\nPor ejemplo, se puede crear una función que eleve al cuadrado:\n\ncuadrado <- function(x) { # x = parámetro\n    y = x ^ 2 # asiganción de variables solo dentro de la función\n    return(y) # especificar valor retornado (no necesario completamente)\n}\n\n\na <- 13\nb <- c(20,30,22,2,1)\ncuadrado(a)\n\n[1] 169\n\ncuadrado(b)\n\n[1] 400 900 484   4   1\n\n\nEs importante tener en cuenta que los nombres de las funciones en R deben cumplir las mismas reglas que los nombres de las variables. Además, es recomendable incluir comentarios explicativos dentro del cuerpo de la función para facilitar su comprensión y uso posterior.\nActividad:\nActividad: Crear una función que calcule la hipotenusa de un triángulo rectángulo (Teorema de Pitágoras):\n\n\n\nEstablece que el cuadrado de la longitud de la hipotenusa es igual a la suma de los cuadrados de las longitudes de los catetos.\nc^2 = {a^2}+{b^2}\nPor lo cual:\nc = \\sqrt{{a^2}+{b^2}}\n\n\n\n\n\n\nAyuda\n\n\n\n\nhipotenusa <- function(a, b){\n  #h <-     # En esta parte escribir la función\n  return(h)\n}\nr1 <-  hipotenusa(a = 5,  b = 5)\n\n\n\nEncontrar la Hipotenusa de:\nh=?, a = 10, b = 6\nh=?, a = 5, b = 4\nh=?, a = 3, b = 4"
  },
  {
    "objectID": "loops_R.html#estructuras-condicionales",
    "href": "loops_R.html#estructuras-condicionales",
    "title": "Appendix D — Estructura de Control en R",
    "section": "D.1 Estructuras condicionales",
    "text": "D.1 Estructuras condicionales\nLas estructuras condicionales son una de las tres estructuras de control principales en R. Estas estructuras permiten ejecutar un bloque de código solo si se cumple una condición determinada.\nLa estructura condicional más común en R es “if”. La sintaxis básica de la estructura “if” es la siguiente:\n\nif(Condición) {\n  operaciones_si_la_condición_es_TRUE\n}\n\nLa “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, el bloque de código dentro del “if” se ejecutará. Si la condición es falsa, el bloque de código dentro del “if” se ignorará.\nPor ejemplo, le pedimos a R que nos muestre el texto “Verdadero” si la condición se cumple.\n\n# Se cumple la condición y se muestra \"verdadero\"\nif(4 > 3) {\n  \"Verdadero\"\n}\n\n[1] \"Verdadero\"\n\n\n\n# No se cumple la condición y no pasa nada\nif(4 > 5) {\n  \"Verdadero\"\n}\n\nTambién se puede agregar un bloque de código opcional para el caso en que la condición sea falsa utilizando la estructura “else”. La sintaxis básica de la estructura “if” con “else” es la siguie\nSI esta condición es es cierta, ENTONCES haz estas operaciones, DE OTRO MODO haz estas otras operaciones.\n\nif(condición) {\n  operaciones_si_la_condición_es_TRUE\n} else {\n  operaciones_si_la_condición_es_FALSE\n}\n\nUsando los ejemplos anteriores, podemos mostrar “Falso” si no se cumple la condición, en lugar de que no ocurra nada\n\n# Se cumple la condición y se muestra \"Verdadero\"\nif(4 > 3) {\n  \"Verdadero\"\n} else {\n  \"Falso\"\n}\n\n[1] \"Verdadero\"\n\n\nLa estructura “ifelse” es otra forma de estructura condicional que permite ejecutar diferentes bloques de código en función de la condición. La sintaxis básica de la estructura “ifelse” es la siguiente:\n\nifelse(condición, expresión1, expresión2)\n\nSi la “condición” es verdadera, se ejecutará “expresión1”. Si la “condición” es falsa, se ejecutará “expresión2”.\nAdemás, se pueden anidar varias estructuras condicionales utilizando la sintaxis de “if” y “else”. Por ejemplo:\n\nif (condición1) {\n  # Código a ejecutar si la condición1 es verdadera\n} else if (condición2) {\n  # Código a ejecutar si la condición1 es falsa y la condición2 es verdadera\n} else {\n  # Código a ejecutar si todas las condiciones son falsas\n}\n\nEn resumen, las estructuras condicionales en R son herramientas muy útiles para controlar el flujo de ejecución de un programa en función de ciertas condiciones. Estas estructuras permiten crear soluciones más eficientes y complejas al permitir que los programas tomen decisiones y realicen acciones en función de las condiciones que se presenten."
  },
  {
    "objectID": "loops_R.html#estructuras-de-bucles",
    "href": "loops_R.html#estructuras-de-bucles",
    "title": "Appendix D — Estructura de Control en R",
    "section": "D.2 Estructuras de bucles",
    "text": "D.2 Estructuras de bucles\nLas estructuras de bucles son una de las tres estructuras de control principales en R. Estas estructuras permiten ejecutar un bloque de código repetidamente mientras se cumpla una condición determinada. En R, existen tres estructuras de bucles principales: “while”, “for” y “repeat”.\nBeneficios\n\nEs más fácil ver el objetivo de tu código; lo diferente llama más atención a la vista que aquello que permanece igual.\nEs más sencillo responder a cambios en los requerimientos. A medida que tus necesidades cambian, solo necesitarás realizar cambios en un lugar, en vez de recordar cambiar en cada lugar donde copiaste y pegaste el código.\nEs probable que tengas menos errores porque cada línea de código es utilizada en más lugares.\n\n\nD.2.1 Estructura de bucle “for”:\nLa estructura “for” permite repetir la ejecución de un bloque de código un número determinado de veces. La sintaxis básica de la estructura “for” es la siguiente:\n\nfor (variable in secuencia) {\n  # Código a ejecutar para cada elemento en la secuencia\n}\n\nLa “secuencia” es un objeto que contiene una serie de elementos. La “variable” toma el valor de cada elemento de la secuencia en cada iteración del bucle. En cada iteración, se ejecutará el bloque de código dentro del “for” para ese valor de la variable.\nEjemplo simple: print una secuencia\n\nfor (i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nEjemplo 2: Guardando los resultados en un vector\n\ndado <- 1:6\nmi_vector <- NULL\nfor(cara in dado) {\n  mi_vector[cara] <- cara ^ 2\n}\nmi_vector\n\n[1]  1  4  9 16 25 36\n\n\nEjemplo 3: Loops con vectores\n\nalumnos <- c(\"Carmen\", \"Adriana\", \"Marco\", \"Fabi\", \"Brenda\")\n\nfor(i in 1:length(alumnos)) {\n  print(paste(\"Hola,\", alumnos[i], sep = \" \"))\n}\n\n[1] \"Hola, Carmen\"\n[1] \"Hola, Adriana\"\n[1] \"Hola, Marco\"\n[1] \"Hola, Fabi\"\n[1] \"Hola, Brenda\"\n\n\nEjemplo 4: loops en Dataframes\n\ndf <- data.frame(a = rnorm(10), b = rnorm(10),\n                 c = rnorm(10), d = rnorm(10))\n\nfor(i in 1:ncol(df)){\n  promedio = mean(df[,i])\n  print(promedio)\n}\n\n[1] 0.1380859\n[1] -0.1074155\n[1] -0.03981949\n[1] -0.0326989\n\n\n\n\nD.2.2 Estructura de bucle “while”:\nLa estructura “while” permite repetir la ejecución de un bloque de código mientras se cumpla una condición determinada. La sintaxis básica de la estructura “while” es la siguiente:\n\nwhile (condición) {\n  # Código a ejecutar mientras se cumpla la condición\n}\n\nLa “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, se ejecutará el bloque de código dentro del “while”. Este proceso se repetirá hasta que la condición sea falsa.\n\n\nD.2.3 Estructura de bucle “repeat”:\n\nrepeat {\n  # Código a ejecutar de manera indefinida\n  if (condición) {\n    break\n  }\n}\n\nEl bloque de código dentro del “repeat” se ejecutará de manera indefinida hasta que se encuentre la sentencia “break”, que permite salir del bucle. La “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, se ejecutará la sentencia “break” y se saldrá del bucle."
  },
  {
    "objectID": "loops_R.html#estructuras-de-control-de-flujo",
    "href": "loops_R.html#estructuras-de-control-de-flujo",
    "title": "Appendix D — Estructura de Control en R",
    "section": "D.3 Estructuras de control de flujo",
    "text": "D.3 Estructuras de control de flujo\n“next” y “break” son palabras clave importantes en R que se utilizan en las estructuras de control de flujo, específicamente en las estructuras de bucle. “next” se utiliza para saltar a la siguiente iteración del bucle sin ejecutar el resto del código dentro del bucle, mientras que “break” se utiliza para detener el bucle de forma abrupta, incluso si la condición del bucle todavía se cumple.\n\nD.3.1 Estructuras de control “next”:\n“next” se utiliza en una estructura de bucle para saltar a la siguiente iteración del bucle sin ejecutar el resto del código dentro del bucle. Es decir, si se encuentra la palabra clave “next” dentro de un bucle, se omitirá el código que viene después y el bucle pasará inmediatamente a la siguiente iteración. La palabra clave “next” es útil cuando se desea saltar una iteración específica del bucle, sin afectar el resto del código.\nPor ejemplo, en el siguiente código se utiliza la palabra clave “next” para omitir la impresión del número 3 dentro del bucle “for”:\n\nfor (i in 1:5) {\n  if (i == 3) {\n    next\n  }\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 4\n[1] 5\n\n\n\n\nD.3.2 Estructuras de control “break”:\n“break”, por otro lado, se utiliza en una estructura de bucle para detener el bucle de forma abrupta, incluso si la condición del bucle todavía se cumple. Es decir, si se encuentra la palabra clave “break” dentro de un bucle, se detendrá el bucle de inmediato y se continuará con la ejecución del código que viene después del bucle. La palabra clave “break” es útil cuando se desea detener el bucle en un punto específico sin tener que esperar a que la condición del bucle se deje de cumplir.\nPor ejemplo, en el siguiente código se utiliza la palabra clave “break” para detener el bucle “while” cuando el valor de “i” es mayor que 5:\n\ni <- 1\nwhile (i < 10) {\n  if (i > 5) {\n    break\n  }\n  print(i)\n  i <- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5"
  },
  {
    "objectID": "loops_R.html#referencias",
    "href": "loops_R.html#referencias",
    "title": "Appendix D — Estructura de Control en R",
    "section": "D.4 Referencias",
    "text": "D.4 Referencias\n\nhttps://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html\nhttps://es.r4ds.hadley.nz/iteración.html\nhttps://rstudio-pubs-static.s3.amazonaws.com/623888_497a5388a98545c48e9b5b6bec4056f6.html"
  },
  {
    "objectID": "tidyverse_R.html#introducción-a-tidyverse",
    "href": "tidyverse_R.html#introducción-a-tidyverse",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.1 Introducción a Tidyverse",
    "text": "E.1 Introducción a Tidyverse\nTidyverse es una colección de paquetes diseñados para Ciencia de Datos.\n\n\n\n\n\n\n# instalación\ninstall.packages(\"tidyverse\")\n\nTodos los paquetes comparten una filosofía de diseño, una gramática y estructuras de datos.\nEsta filosofía promueve\n\nEn Pipes, navegarás dentro del pipe, %>%, para anidar instrucciones\nSi bien copiar-y-pegar (copy-and-paste) es una herramienta poderosa, deberías evitar utilizarla más de dos veces. Repetir el código es peligroso porque puede llevar a errores e inconsistencias.\nA medida que comiences a escribir funciones más potentes, necesitarás una base sólida acerca de las estructuras de datos.\nLas funciones nos permiten evitar la repetición de código; sin embargo, muchas veces necesitas repertir las mismas acciones con diferentes inputs. Puedes hacer esto con herramientas de iteración."
  },
  {
    "objectID": "tidyverse_R.html#estructura-de-un-dataframe",
    "href": "tidyverse_R.html#estructura-de-un-dataframe",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.2 Estructura de un dataframe",
    "text": "E.2 Estructura de un dataframe\n\n\n\nLectura de Base de SII\n\nsuppressPackageStartupMessages(library(dplyr))\nsuppressPackageStartupMessages(library(sf))\ntbl_sii  <- readRDS(\"data/rds/mz_constru_SII.rds\") %>% \n  st_drop_geometry() # descartar geometrias solo usar la tabla de datos\n\nhead(tbl_sii)\n\n# A tibble: 6 × 10\n  n_com   manzana   reg cod_com num_manz oficinas comercio vivienda total   AREA\n  <chr>   <chr>   <dbl>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl> <dbl>  <dbl>\n1 IQUIQUE 1201-0      1    1201        0        0        0        0     0   585.\n2 IQUIQUE 1201-0      1    1201        0        0        0        0     0 17291.\n3 ALTO H… 1211-0      1    1211        0        0        0        0     0  1859.\n4 ALTO H… 1211-0      1    1211        0        0        0        0     0   442.\n5 ALTO H… 1211-0      1    1211        0        0        0        0     0   205.\n6 ALTO H… 1211-0      1    1211        0        0        0        0     0  1200."
  },
  {
    "objectID": "tidyverse_R.html#funciones-básicas-dplyr",
    "href": "tidyverse_R.html#funciones-básicas-dplyr",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.3 Funciones básicas dplyr",
    "text": "E.3 Funciones básicas dplyr\n\n\n\n\nE.3.1 Select\nselect Seleccionar variables relevantes\n\n# seleccionar nomnres de columnas que deseo conservar\ntbl_sii %>%\n  select(n_com, oficinas, comercio, vivienda)\n\n# A tibble: 210,662 × 4\n   n_com         oficinas comercio vivienda\n   <chr>            <dbl>    <dbl>    <dbl>\n 1 IQUIQUE              0        0        0\n 2 IQUIQUE              0        0        0\n 3 ALTO HOSPICIO        0        0        0\n 4 ALTO HOSPICIO        0        0        0\n 5 ALTO HOSPICIO        0        0        0\n 6 ALTO HOSPICIO        0        0        0\n 7 ALTO HOSPICIO        0        0        0\n 8 ALTO HOSPICIO        0        0        0\n 9 ALTO HOSPICIO        0        0        0\n10 ALTO HOSPICIO        0        0        0\n# ℹ 210,652 more rows\n\n# seleccionar nomnres de columnas que deseo eliminar anteponiendo un \"-\"\ntbl_sii %>%\n  select(-cod_com)\n\n# A tibble: 210,662 × 9\n   n_com         manzana   reg num_manz oficinas comercio vivienda total   AREA\n   <chr>         <chr>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl> <dbl>  <dbl>\n 1 IQUIQUE       1201-0      1        0        0        0        0     0   585.\n 2 IQUIQUE       1201-0      1        0        0        0        0     0 17291.\n 3 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  1859.\n 4 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   442.\n 5 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   205.\n 6 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  1200.\n 7 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  4548.\n 8 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   130.\n 9 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   300.\n10 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  6488.\n# ℹ 210,652 more rows\n\n\n\n\nE.3.2 Filter\n\nmi_comuna <- \"LAS CONDES\" \n\nsii_com <- tbl_sii %>%\n  filter(n_com == mi_comuna) \n \nhead(sii_com, 5)\n\n# A tibble: 5 × 10\n  n_com    manzana   reg cod_com num_manz oficinas comercio vivienda total  AREA\n  <chr>    <chr>   <dbl>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl> <dbl> <dbl>\n1 LAS CON… 15108-…    13   15108     2358        0        0     1316  1390 2358.\n2 LAS CON… 15108-…    13   15108     2360        0        0     1590  1622 2280.\n3 LAS CON… 15108-…    13   15108     2362        0        0     1436  1502 2659.\n4 LAS CON… 15108-…    13   15108     2364        0        0     1926  1926 3348.\n5 LAS CON… 15108-…    13   15108     2366        0        0     2584  2656 4390.\n\n\nfilter: Operadores Lógicos\n\n\n\n\n\n\n\n\n\n\n\nOperador\nComparación\nEjemplo\nResultado\n\n\n\n\nx | y\nx Ó y es verdadero\nTRUE | FALSE\nTRUE\n\n\nx & y\nx Y y son verdaderos\nTRUE & FALSE\nFALSE\n\n\n!x\nx no es verdadero (negación)\n!TRUE\nFALSE\n\n\nisTRUE(x)\nx es verdadero (afirmación)\nisTRUE(TRUE)\nTRUE\n\n\n\n\n\nFiltrar las manzanas que tengan valores de oficina y comercio mayores a 0\n\nsii_com %>%\n  filter(oficinas > 0 & comercio > 0) \n\n# A tibble: 493 × 10\n   n_com manzana   reg cod_com num_manz oficinas comercio vivienda  total   AREA\n   <chr> <chr>   <dbl>   <dbl>    <dbl>    <dbl>    <dbl>    <dbl>  <dbl>  <dbl>\n 1 LAS … 15108-…    13   15108     2400     322     3388    65422  1.22e5 1.06e5\n 2 LAS … 15108-…    13   15108     2407   30864     2518        0  7.50e4 4.04e3\n 3 LAS … 15108-…    13   15108     1392     424     9902        0  1.58e4 1.27e4\n 4 LAS … 15108-…    13   15108      336   45190     1432        0  8.28e4 3.24e3\n 5 LAS … 15108-…    13   15108      338     424.     244.    9993. 1.17e4 1.11e4\n 6 LAS … 15108-…    13   15108      338     414.     238.    9765. 1.14e4 1.06e4\n 7 LAS … 15108-…    13   15108      339    1120     5274     7748  1.49e4 9.38e3\n 8 LAS … 15108-…    13   15108      340     250       72    55206  7.23e4 1.22e4\n 9 LAS … 15108-…    13   15108      342     494     1914    47690  6.97e4 1.62e4\n10 LAS … 15108-…    13   15108      349   17826     1568        0  3.38e4 1.84e3\n# ℹ 483 more rows"
  },
  {
    "objectID": "tidyverse_R.html#resúmenes-estadísticos-con-dplyr",
    "href": "tidyverse_R.html#resúmenes-estadísticos-con-dplyr",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.4 Resúmenes Estadísticos con dplyr",
    "text": "E.4 Resúmenes Estadísticos con dplyr\n\n\n\nContabilizar cuantos metros cuadrados de oficina por cada comuna.\n\ntbl_resumen <-  tbl_sii %>%\n  group_by(n_com) %>%\n  summarise(Cantidad_mz = n(),\n            Total_of = sum(oficinas)) %>%\n  arrange(desc(Total_of)) # Ordenar\n\ntbl_resumen\n\n# A tibble: 170 × 3\n   n_com           Cantidad_mz Total_of\n   <chr>                 <int>    <dbl>\n 1 SANTIAGO CENTRO         686  6105996\n 2 LAS CONDES             2310  4248336\n 3 PROVIDENCIA             885  3495426\n 4 HUECHURABA             1160  1006138\n 5 QUILICURA              2592   751874\n 6 VITACURA                950   743734\n 7 SANTIAGO SUR            623   669270\n 8 Ã‘UÃ‘OA                1337   637982\n 9 SANTIAGO OESTE          586   586724\n10 PUDAHUEL               2775   561868\n# ℹ 160 more rows\n\n\nActividad\n\nContabilizar cuantos metros cuadrados de Comercio hay por cada comuna rdenar de mayor a menor.\nCrear tabla con las 10 comunas que tienen mayor densisdad de Comercio\n\n\n\n\n\n\n\nDensidad de comercio\n\n\n\nSe puede entender como la división de la cantidad de metros cuadrados de comercio dividio por el total de metros cuadrados."
  },
  {
    "objectID": "tidyverse_R.html#visualización-de-variables",
    "href": "tidyverse_R.html#visualización-de-variables",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.5 Visualización de Variables",
    "text": "E.5 Visualización de Variables\n\nE.5.1 Función Plot\n\noptions(scipen = 999) # evitas notación cientiífica\nhist(sii_com$vivienda, breaks = 50,\n     main = \"Histograma mt2 de Viviendas\", col = \"#225ea8\")\n\n\n\n# colores:https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3\n\n\n\nE.5.2 Package ggplot2\n\nlibrary(ggplot2)\nggplot(sii_com, aes(x = vivienda)) + \n  geom_histogram(bins = 50, fill = \"#225ea8\", color =\"black\")\n\n\n\n\n\n\n\n\nggplot2 con estilos y características\n\nggplot(sii_com, aes(x = vivienda)) +\n  geom_histogram(bins = 50, color = \"#c7e9b4\", fill = \"#1d91c0\")+\n  theme_bw()+\n  labs(title=\"Histograma mt2 de Viviendas\", x =\"Mt2. Viviendas\", y = \"Frecuencias\")+\n  theme(plot.title = element_text(face = \"bold\",colour= \"gray60\", size=10))"
  },
  {
    "objectID": "tidyverse_R.html#referencias",
    "href": "tidyverse_R.html#referencias",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.6 Referencias:",
    "text": "E.6 Referencias:\n\nR para Ciencia de Datos\nRStudio para Estadística Descriptiva en Ciencias Sociales\nhttps://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html\nhttps://rstudio-pubs-static.s3.amazonaws.com/623888_497a5388a98545c48e9b5b6bec4056f6.html\nPaletas de colores"
  },
  {
    "objectID": "espacial_R.html#introducción",
    "href": "espacial_R.html#introducción",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.1 Introducción",
    "text": "F.1 Introducción\nUn rasgo es una cosa, un objeto del mundo real, como un edificio o un árbol. Al igual que los objetos, suelen estar formados por otros objetos. Lo mismo ocurre con los rasgos: un conjunto de rasgos puede formar un único rasgo. Una masa forestal puede ser un rasgo, un bosque puede ser un rasgo, una ciudad puede ser un rasgo. Un píxel de una imagen de satélite puede ser un rasgo, una imagen completa también puede ser un rasgo.\nLos elementos tienen una geometría que describe su ubicación en la Tierra y atributos que describen otras propiedades. La geometría de un árbol puede ser la delineación de su copa, de su tallo o el punto que indica su centro. Otras propiedades pueden ser su altura, color, diámetro a la altura del pecho en una fecha determinada, etc."
  },
  {
    "objectID": "espacial_R.html#lectura-de-insumos-espaciales",
    "href": "espacial_R.html#lectura-de-insumos-espaciales",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.2 Lectura de Insumos Espaciales",
    "text": "F.2 Lectura de Insumos Espaciales\n\n# install.packages(\"sf\")\nlibrary(sf)\ncrs_ll <- \"+proj=longlat +datum=WGS84 +no_defs\"\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\ncenso <-  readRDS(\"data/rds/Zonas_Censales_2017_Nacional.rds\")"
  },
  {
    "objectID": "espacial_R.html#transformar-a-objeto-sf-simple-features",
    "href": "espacial_R.html#transformar-a-objeto-sf-simple-features",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.3 Transformar a objeto sf (simple features)",
    "text": "F.3 Transformar a objeto sf (simple features)\n\n# transformar a objeto sf (simple features)\ncenso_sf <- st_as_sf(censo)\n# head(censo_sf)\nnames(censo_sf)\n\n [1] \"REGION\"     \"NOM_REGION\" \"PROVINCIA\"  \"NOM_PROVIN\" \"COMUNA\"    \n [6] \"NOM_COMUNA\" \"URBANO\"     \"DISTRITO\"   \"LOC_ZON\"    \"GEOCODIGO\" \n[11] \"SHAPE_Leng\" \"SHAPE_Area\" \"geometry\""
  },
  {
    "objectID": "espacial_R.html#filtros-espaciales-por-data",
    "href": "espacial_R.html#filtros-espaciales-por-data",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.4 Filtros espaciales por data",
    "text": "F.4 Filtros espaciales por data\n\nlibrary(dplyr)\nmi_communa <-  \"LAS CONDES\"\n\nzonas_com <-  censo_sf %>% \n  filter(NOM_COMUNA == mi_communa)\n\nzonas_com %>% head()\n\nSimple feature collection with 6 features and 12 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -70.56629 ymin: -33.41713 xmax: -70.47884 ymax: -33.36421\nGeodetic CRS:  +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0\n            REGION                       NOM_REGION PROVINCIA NOM_PROVIN COMUNA\n13114051001     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n13114041001     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n13114041003     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n13114161002     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n13114151003     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n13114021002     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n            NOM_COMUNA     URBANO DISTRITO LOC_ZON   GEOCODIGO SHAPE_Leng\n13114051001 LAS CONDES LAS CONDES        5       1 13114051001 0.02302722\n13114041001 LAS CONDES LAS CONDES        4       1 13114041001 0.09575698\n13114041003 LAS CONDES LAS CONDES        4       3 13114041003 0.06782420\n13114161002 LAS CONDES LAS CONDES       16       2 13114161002 0.06482893\n13114151003 LAS CONDES LAS CONDES       15       3 13114151003 0.04135677\n13114021002 LAS CONDES LAS CONDES        2       2 13114021002 0.04687558\n              SHAPE_Area                       geometry\n13114051001 3.357387e-05 MULTIPOLYGON (((-70.56008 -...\n13114041001 2.708800e-04 MULTIPOLYGON (((-70.47951 -...\n13114041003 2.451087e-04 MULTIPOLYGON (((-70.5267 -3...\n13114161002 1.450608e-04 MULTIPOLYGON (((-70.50789 -...\n13114151003 8.288767e-05 MULTIPOLYGON (((-70.51477 -...\n13114021002 5.754391e-05 MULTIPOLYGON (((-70.53606 -..."
  },
  {
    "objectID": "espacial_R.html#visualización-cartográficas",
    "href": "espacial_R.html#visualización-cartográficas",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.5 Visualización Cartográficas",
    "text": "F.5 Visualización Cartográficas\n\nF.5.1 Visualización estática Simple\n\n## Visualizar\n# Consideración el plot se realiza sobre la columna geometry\n\nnombre_plot <-  paste0(\"COMUNA DE \", mi_communa)\nplot(zonas_com$geometry, main = nombre_plot,col =\"orange\")\n\n\n\n\n\n\n\n\n\n\nF.5.2 Visualización estática con ggplot2\n\nlibrary(ggplot2)\n\n# Visualización ggplot y sf\nggplot() +\n  geom_sf(data = zonas_com, fill = \"orange\", alpha=0.5)+\n  ggtitle(nombre_plot) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"),\n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n\n\n\n\nF.5.3 Visualización Dinámica con mapview\n\n# install.packages(\"mapview\")\nlibrary(mapview)\nm <- mapview(zonas_com, alpha = 0.5,\n        col.regions = \"orange\", color=\"gray80\",\n        legend =FALSE, cex = 3)\nm"
  },
  {
    "objectID": "espacial_R.html#referencias",
    "href": "espacial_R.html#referencias",
    "title": "Appendix F — Objetos Espaciales en R",
    "section": "F.6 Referencias",
    "text": "F.6 Referencias\nSimple Features for R"
  },
  {
    "objectID": "install_rgee.html#registrarse-en-gee",
    "href": "install_rgee.html#registrarse-en-gee",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.1 Registrarse en GEE",
    "text": "G.1 Registrarse en GEE\nPara acceder de los recursos de la plataforma de Google Earth Engine desde R de acuerdo al programa del curso, correspondiendo a los siguientes pasos:\n\n\nTener cuenta en google (gmail)\n\n\nDirigirse a la siguiente página web https://earthengine.google.com\n\n\n\n\n\n\n\nRegistrarse con la cuenta google, presionando botón “sing up” esquina superior derecha.\n\n\nRecibir un correo de confirmación en el gmail."
  },
  {
    "objectID": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "href": "install_rgee.html#instalación-de-librería-rgee-en-r",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.2 Instalación de librería Rgee en R",
    "text": "G.2 Instalación de librería Rgee en R\nEl package rgee es una “librería cliente” de Earth Engine para R, que permite a los usuarios aprovechar las ventajas que presenta el ecosistema espacial de R dentro de Google Earth Engine y viceversa.\nTodas las clases, módulos y funciones de la API de Python de Earth Engine están disponibles en R gracias a la librería reticulate; finalmente rgee adiciona nuevos features como el diseño del imput y output de datos, la visualización en mapas interactivos, la facil extracción de series de tiempo, el manejo y la visualización de metadato\n\n\n\nOpción 1: Diretamente desde CRAN\n\ninstall.packages(\"rgee\")\n\n\nOpción de Desarrollo: Desde la Versión de Desarrollo alojada en Github\n\n# install.packages(\"remotes\")\nremotes::install_github(\"r-spatial/rgee\", force = TRUE)\n\nInstalar Dependencias\n\nlibrary(rgee)\nee_install() # Consulta sobre crear ambiente virtual python \"Yes\"\n# Ahora de debe reiniciar Rstudio\n\nRevisión de Instalación correcta\n\n# Iniciar Servicio\nlibrary(rgee)\nee_Initialize()\n\n# Selección de producto satelital (Modelo Digital de Elevación)\nsrtm <- ee$Image(\"USGS/SRTMGL1_003\")\n\n# parámetros de visualización\nviz <- list(\n  max = 4000,\n  min = 0,\n  palette = c(\"#000000\",\"#5AAD5A\",\"#A9AD84\",\"#FFFFFF\")\n)\n\n# Visualización map dinámico\nm <- Map$addLayer(\n  eeObject = srtm,\n  visParams =  viz,\n  name = 'SRTM'\n)\nm"
  },
  {
    "objectID": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "href": "install_rgee.html#usuarios-con-experiencie-en-enviroments-virtuales",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.3 Usuarios con experiencie en enviroments virtuales",
    "text": "G.3 Usuarios con experiencie en enviroments virtuales\n\n#Use ee_install_set_pyenv (Recommended for users with experience with Python environments)\n\nrgee::ee_install_set_pyenv(\n  py_path = \"/home/csaybar/.virtualenvs/rgee/bin/python\", # Change it for your own Python PATH\n  py_env = \"rgee\" # Change it for your own Python ENV\n)"
  },
  {
    "objectID": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "href": "install_rgee.html#otras-librerías-que-se-deben-instalar",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.4 Otras Librerías que se deben instalar",
    "text": "G.4 Otras Librerías que se deben instalar\n\ninstall.packages(\"sf\") # Mapas dinámicos\ninstall.packages(\"mapview\") # Mapas dinámicos\ninstall.packages(\"reticulate\") # interface python\ninstall.packages(\"jsonlite\") #manipulación de datos tipo Json\ninstall.packages('tidyverse') # Para ciencia de datos\ninstall.packages('cptcity') #Para manejar paletas decolores\ninstall.packages('viridis') #Para manejar paletas decolores\ninstall.packages('ggmap') # Para manejar tipos de basemap\ninstall.packages('plot3D') #plot objetos 3d"
  },
  {
    "objectID": "install_rgee.html#referencias",
    "href": "install_rgee.html#referencias",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.5 Referencias",
    "text": "G.5 Referencias\nGoogle Earth Engine for R https://github.com/r-spatial/rgee\nEjemplos https://csaybar.github.io/rgee-examples/\nManual en Español https://barja8.github.io/Handbook_rgee/pdf/vol01.pdf\nIntroduction to rgee https://cran.r-project.org/web/packages/rgee/vignettes/rgee01.html"
  },
  {
    "objectID": "install_rgee.html#contactos",
    "href": "install_rgee.html#contactos",
    "title": "Appendix G — Instalación de Rgee",
    "section": "G.6 Contactos",
    "text": "G.6 Contactos\nDenis Berroeta G.\nInvestigador, Centro Inteligencia Territorial, Design Lab UAI\ndenis.berroeta@uai.cl\nAv. Presidente Errázuriz 3485, Las Condes\n**Felipe Matas*\nAnalista, Centro Inteligencia Territorial, Design Lab UAI\nfelipe.matas@edu.uai.cl\nAv. Presidente Errázuriz 3485, Las Condes"
  },
  {
    "objectID": "indices.html#section",
    "href": "indices.html#section",
    "title": "7  S5: Índices Espectrales",
    "section": "7.1 ",
    "text": "7.1 \n\n\n\n\n\n\n\n\n\n\n\nCargar Librerías\n\nlibrary(sf)\nlibrary(rgee)\nee_Initialize('denis.berroeta@gmail.com', drive = TRUE)\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(viridis)"
  },
  {
    "objectID": "indices.html#monitoreo-de-sequía-laguna-de-aculeo",
    "href": "indices.html#monitoreo-de-sequía-laguna-de-aculeo",
    "title": "7  S5: Índices Espectrales",
    "section": "7.4 Monitoreo de Sequía Laguna de Aculeo",
    "text": "7.4 Monitoreo de Sequía Laguna de Aculeo\nPara el siguiente análisis utilizaremos el NDWI: Normalized Difference Water Index)\n\n7.4.1 El Problema\n\n\n\n\n\nNoticias Relacionadas:\n“Laguna de Aculeo, una de las primeras víctimas del cambio climático y megasequía según estudio”. Biobiochile.cl 20-JUN-2019\n“La sequía de Aculeo vista desde el espacio”. Diario La Tercera 11-MAY-2018\n“En desaparecida laguna de Aculeo proponen que nueva Constitución tenga sello medioambiental: Greenpeace ilustra la grave emergencia climática en Chile” Greenpeace 28-NOV-2019\n\n\n7.4.2 Lectura de Insumo Cuerpos de Agua Nacional\n\nmasas_agua <- st_read(\"data/shape/masas_agua.shp\", quiet = T)\nmasas_agua\n\nSimple feature collection with 16644 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -5659.382 ymin: 3803587 xmax: 692350 ymax: 8050958\nProjected CRS: WGS 84 / UTM zone 19S\nFirst 10 features:\n                                    NOMBRE TIPO_MAGUA COMUNA    AREA_KM2 RULEID\n1                       Laguna Tebinquiche     Laguna   <NA>  2.08693247      5\n2                                     <NA>     Laguna   <NA>  0.84982790      5\n3                           Salar de Pujsa      Salar   <NA>  0.22226662      7\n4                           Salar de Pujsa      Salar   <NA> 16.64594244      7\n5                         Salar de Atacama      Salar   <NA> 49.61221690      7\n6                           Salar de Pujsa      Salar   <NA>  0.02636444      7\n7            Salar de Loyoques o Quisquiro      Salar   <NA> 65.49493327      7\n8            Salar de Loyoques o Quisquiro      Salar   <NA>  0.63644089      7\n9                           Salar de Pujsa      Salar   <NA>  0.08644732      7\n10 Laguna en Salar de Loyoques o Quisquiro     Laguna   <NA>  0.02395804      5\n   SHAPE_Leng  SHAPE_Area                       geometry\n1  12353.4677  2086932.47 MULTIPOLYGON (((575205.1 74...\n2   4397.5639   849827.90 MULTIPOLYGON (((661560.1 74...\n3   3305.8444   222266.62 MULTIPOLYGON (((652931.2 74...\n4  26208.2874 16645942.44 MULTIPOLYGON (((652560 7434...\n5  44044.4984 49612216.90 MULTIPOLYGON (((569340.4 74...\n6    606.6370    26364.45 MULTIPOLYGON (((653547.4 74...\n7  67250.4947 65494933.27 MULTIPOLYGON (((672122.6 74...\n8   5459.5505   636440.89 MULTIPOLYGON (((671993 7433...\n9   1147.0949    86447.32 MULTIPOLYGON (((653825.7 74...\n10   686.3645    23958.04 MULTIPOLYGON (((673224.5 74...\n\n#Buscar nombre del cuerpo de aguar por patrón de texto\ngrep(pattern = \"Aculeo$\", x = masas_agua$NOMBRE, value = T)\n\n[1] \"Laguna de Aculeo\"\n\n# Leer Laguna Aculeo\nlag_aculeo <- masas_agua%>%\n  filter(NOMBRE == \"Laguna de Aculeo\")%>%\n  sfheaders::sf_remove_holes() ## remover poligonos internos%>%>%\n\n\nplot(lag_aculeo$geometry,col = \"skyblue\",  main = \"Laguna Aculeo\")\n\n\n\n\n\n#Laguna Formato ee\nlag_aculeo_ee <- lag_aculeo%>%\n  st_buffer(500)%>%\n  st_transform(4326)%>%  #crs atlon\n  sf_as_ee()\n\n# regiòn  para definir regiòn de interès para los mapas\nregion <- lag_aculeo_ee$geometry()$bounds()\n\n\n\n7.4.3 Lectura de insumo satelital visualización previa\n\nimagen <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$\n  filterBounds(region)$\n  filterDate('2018-01-01','2018-12-31')$\n  filterMetadata('CLOUD_COVER','less_than', 5)$\n  median()$\n  clip(region)\n\n\nndwi <- imagen$normalizedDifference(c(\"B3\", \"B5\"))$clip(region)\nndwiMask <- ndwi$updateMask(ndwi$gte(0))#greater than or equal to the given value.\n\n\n\nndwiViz <- list(min = 0, max = 1, palette = c(\"white\", \"#00FFFF\",'#0080FF', \"#0000FF\"))\nimgViz <- list(min = 0, max = 0.5,  bands = c(\"B4\", \"B3\", \"B2\"), gamma = c(0.95, 1.1, 1))\n\nMap$centerObject(region, zoom = 13)\nmapa <- Map$addLayer(imagen, imgViz,'RGB')+\n  Map$addLayer(ndwiMask, ndwiViz,'NDWI')\nmapa\n\n\n\n\n\n\n\n7.4.4 Construcción de un Mosaico con NDWI y Falso Color\n\nimageRGB <- imagen$visualize(bands = c('B5', 'B4', 'B3'), max = 0.5, gamma = c(0.95, 1.1, 1))\nndwiRGB <- ndwiMask$visualize(min = 0, max = 1, palette = c('#00FFFF', '#0000FF'))\nmosaic <- ee$ImageCollection(c(imageRGB, ndwiRGB))$mosaic() #función crea mo\nMap$centerObject(region, zoom = 13)\nMap$addLayer(mosaic , list(), 'mosaic')\n\n\n\n\n\n\n\n7.4.5 Creación de Serie Anual desde el 2015 al 2020\n\nimagen <- ee$ImageCollection('LANDSAT/LC08/C01/T1_TOA')$\n  filterBounds(region)$\n  filterDate('2015-01-01','2020-12-31')$\n  filterMetadata('CLOUD_COVER','less_than', 5)\nanual <- ee$List$sequence(2015, 2020)\n\n\nanual_l8 <- function(y) {\n  imagen$filter(ee$Filter$calendarRange(y, y, \"year\"))$\n    median()$\n    select(\"B4\", \"B3\", \"B2\")$\n    clip(region)}\n\nl8_year <- anual$map(ee_utils_pyfunc(anual_l8))\nl8_year_2015 <- ee$Image(l8_year$get(0))\nl8_year_2016 <- ee$Image(l8_year$get(1))\nl8_year_2017 <- ee$Image(l8_year$get(2))\nl8_year_2018 <- ee$Image(l8_year$get(3))\nl8_year_2019 <- ee$Image(l8_year$get(4))\nl8_year_2020 <- ee$Image(l8_year$get(5))\n\nvisparams <- list(\n  bands = c(\"B4\", \"B3\", \"B2\"), min = 0,max = 0.6,gamma = 1.4)\n\nMap$centerObject(region, zoom = 13)\nmap1 <- Map$addLayer(l8_year_2015, visparams, name = \"2015\")+\n  Map$addLayer(l8_year_2016, visparams, name = \"2016\")+\n  Map$addLayer(l8_year_2017, visparams, name = \"2017\")+\n  Map$addLayer(l8_year_2018, visparams, name = \"2018\")+\n  Map$addLayer(l8_year_2019, visparams, name = \"2019\")+\n  Map$addLayer(l8_year_2019, visparams, name = \"2020\")\nmap1\n\n# referencias: # https://github.com/r-spatial/rgee/blob/examples/ImageCollection/creating_monthly_imagery.R"
  },
  {
    "objectID": "indices.html#índices-urbanos",
    "href": "indices.html#índices-urbanos",
    "title": "7  S5: Índices Espectrales",
    "section": "7.2 Índices Urbanos",
    "text": "7.2 Índices Urbanos\nAlgunos ejemplos de índices espectrales normalizados utilizados para analizar el entorno urbano con percepción remota son:\n\nNDBI (Índice de Brillo de la Edificación Normalizado): Este índice se utiliza para identificar y mapear áreas urbanas construidas. Se calcula utilizando la reflectancia en la banda del infrarrojo cercano y la banda del rojo.\nSI (Índice de Suelo): Este índice se utiliza para detectar y mapear la presencia de suelo desnudo en áreas urbanas. Se calcula utilizando la reflectancia en la banda del rojo y la banda del infrarrojo cercano.\n\nEstos índices espectrales normalizados pueden ser útiles para el análisis de la planificación urbana, la gestión del medio ambiente y otros fines relacionados con la ciudad.\nHaciendo uso de proyecto awesome spectral indices que ofrece a los usuarios las herramientas para consultar índices espectrales y las bandas requeridas para el cálculo de un índice. Incluso cuentan con Aplicación web"
  },
  {
    "objectID": "indices.html#introducción",
    "href": "indices.html#introducción",
    "title": "7  S5: Índices Espectrales",
    "section": "7.1 Introducción",
    "text": "7.1 Introducción\nLos índices espectrales son herramientas utilizadas en percepción remota para analizar la reflectancia de la superficie terrestre en diferentes longitudes de onda del espectro electromagnético. Estos índices se basan en la relación entre la reflectancia en dos o más bandas espectrales y se utilizan para medir diferentes propiedades de la vegetación, como la salud, la humedad y la densidad.\nLa más comun formula matemática de diferencia normalizada es la siguiente:\n\\frac{(B_x-B_y)}{(B_x+B_y)} En términos prácticos, se trata de la diferencia entre dos bandas seleccionadas normalizada por su suma. Este tipo de cálculo es muy útil para minimizar (en la medida de lo posible) los efectos de la iluminación (sombras en regiones montañosas, sombras de nubes, etc.) y mejorar las características espectrales que inicialmente no son visibles.\n\n\n\nFigure 7.1: NDVI (Índice de Vegetación de Diferencia Normalizada)\n\n\nAlgunos de los índices espectrales más utilizados son:\n\nNDVI (Índice de Vegetación de Diferencia Normalizada): Este índice se utiliza para medir la salud y densidad de la vegetación. Se calcula utilizando la reflectancia en la banda roja y la banda infrarroja cercana. Un valor alto de NDVI indica una vegetación densa y saludable (Figure 7.1).\nEVI (Índice de Vegetación Mejorado): Este índice también se utiliza para medir la salud y densidad de la vegetación, pero tiene en cuenta factores como la influencia del suelo y la atmósfera. Se calcula utilizando la reflectancia en la banda azul, roja e infrarroja cercana.\nSAVI (Índice de Vegetación Ajustado para Suelo): Este índice se utiliza para reducir la influencia del suelo en la medición de la vegetación. Se calcula utilizando la reflectancia en la banda roja y la infrarroja cercana y tiene en cuenta la cantidad de luz reflejada por el suelo.\nNLI (Índice de Línea de Agua Normalizado): Este índice se utiliza para medir la cantidad de agua en una superficie. Se calcula utilizando la reflectancia en la banda verde y la banda infrarroja cercana.\nNDWI (Índice de Agua Normalizado): Este índice también se utiliza para medir la cantidad de agua en una superficie, pero tiene en cuenta la reflectancia en la banda del infrarrojo de onda corta y la banda verde.\n\nEstos índices espectrales son solo algunos ejemplos de las muchas herramientas disponibles para analizar la vegetación y el agua utilizando percepción remota."
  },
  {
    "objectID": "indices.html#calculo-de-índices-de-urbanos",
    "href": "indices.html#calculo-de-índices-de-urbanos",
    "title": "7  S5: Índices Espectrales",
    "section": "7.3 Calculo de Índices de Urbanos",
    "text": "7.3 Calculo de Índices de Urbanos\nCargar Librerías\n\nlibrary(sf)\nlibrary(rgee)\nee_Initialize('denis.berroeta@gmail.com', drive = TRUE)\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(mapview)\n\n\nSi seleccionamos los índices espectrales obtendremos la siguente lista\n\n\n\n\n\n\n\n\nSeleccionares índices espectrales urbanos (comparaciones de indices urbanos) y escogeremos el NDBI (Normalized Difference Built-Up Index).\n\n\n\nNDBI Normalized Difference Built-Up Index\n\n\n\n7.3.1 Selección de Área de Estudio\n\nmi_comuna <-  \"LAS CONDES\"\nroi <-  readRDS(\"data/rds/zonas_urb_consolidadas.rds\") %>% \n  st_as_sf() %>% \n  filter( NOM_COMUNA == mi_comuna) %>% \n  st_transform(4326) \n\n\nplot(roi$geometry)\n\n\n\n\n\nroi_ee <-  roi%>%\n  st_union() %>% \n  st_geometry() %>% \n  sf_as_ee()\n\n\n\n7.3.2 Selección Imagen Satelital\nPara el sieguiente análisis usaremos el un producto satelital de Sentinel Collections, denominado Harmonized Sentinel-2 MSI: MultiSpectral Instrument, Level-1C\n\nmaskS2clouds <- function(image) {\n  qa <- image$select(\"QA60\")\n  # Bits 10 and 11 are clouds and cirrus, respectively.\n  cloudBitMask <- bitwShiftL(1, 10)\n  cirrusBitMask <- bitwShiftL(1, 11)\n\n  # Both flags should be set to zero, indicating clear conditions.\n  mask <- qa$bitwiseAnd(cloudBitMask)$eq(0)$And(\n    qa$bitwiseAnd(cirrusBitMask)$eq(0)\n  )\n\n  # Return the masked and scaled data, without the QA bands.\n  image$updateMask(mask)$\n    divide(10000)$\n    select(\"B.*\")$\n    copyProperties(image, list(\"system:time_start\"))\n}\n\n\n# Map the function over one year of data and take the median.\n# Load Sentinel-2 TOA reflectance data.\nS2 <- ee$ImageCollection(\"COPERNICUS/S2_HARMONIZED\")$\n  filterDate(\"2016-01-01\", \"2016-12-31\")$\n  filter(ee$Filter$lt(\"CLOUDY_PIXEL_PERCENTAGE\", 20))$\n  map(maskS2clouds)$\n  median()$\n  clip(roi_ee)\n\n\nviz <- list(bands = c(\"B4\", \"B3\", \"B2\"), min = 0, max = 0.3)\nMap$centerObject(eeObject = S2,zoom = 12) \nMap$addLayer(S2, viz, \"RGB\")\n\n\n\n7.3.3 Aplicar Índice\nla función NDBI corresponde a la siguiente:\nNDBI = \\frac{S1-N}{S1+N} Por lo anterior es muy importante conocer los nombres de la bandas para crear correctamente la función, a continuación de exponen las bandas del producto satelital sentinel.\n\n\n\n\n \n  \n    Name \n    Pixel.Size \n    Wavelength \n    Description \n  \n \n\n  \n    B1 \n    60 meters \n    443.9nm (S2A) / 442.3nm (S2B) \n    Aerosols \n  \n  \n    B2 \n    10 meters \n    496.6nm (S2A) / 492.1nm (S2B) \n    Blue \n  \n  \n    B3 \n    10 meters \n    560nm (S2A) / 559nm (S2B) \n    Green \n  \n  \n    B4 \n    10 meters \n    664.5nm (S2A) / 665nm (S2B) \n    Red \n  \n  \n    B5 \n    20 meters \n    703.9nm (S2A) / 703.8nm (S2B) \n    Red Edge 1 \n  \n  \n    B6 \n    20 meters \n    740.2nm (S2A) / 739.1nm (S2B) \n    Red Edge 2 \n  \n  \n    B7 \n    20 meters \n    782.5nm (S2A) / 779.7nm (S2B) \n    Red Edge 3 \n  \n  \n    B8 \n    10 meters \n    835.1nm (S2A) / 833nm (S2B) \n    NIR \n  \n  \n    B8A \n    20 meters \n    864.8nm (S2A) / 864nm (S2B) \n    Red Edge 4 \n  \n  \n    B9 \n    60 meters \n    945nm (S2A) / 943.2nm (S2B) \n    Water vapor \n  \n  \n    B11 \n    20 meters \n    1613.7nm (S2A) / 1610.4nm (S2B) \n    SWIR 1 \n  \n  \n    B12 \n    20 meters \n    2202.4nm (S2A) / 2185.7nm (S2B) \n    SWIR 2 \n  \n\n\n\n\n\n\nF_NDBI<- function (image){\n  ndbi<-image$expression('float(S1-N)/float(S1+N)',\n                         opt_map=list(\"N\"=image$select(\"B8\"),\n                                      \"S1\"=image$select(\"B11\")))$\n    rename(\"NDBI\")\n  return(ndbi)\n}\n\n\nS2_NDBI <- F_NDBI(S2)\n\n\n\n7.3.4 Visualizar Resultados\n\npal_ndbi <- c('white' , 'white', 'white', 'red' , 'red', 'red')\n\nviz_ndbi<- list(min=-1,\n                max=1,\n                palette=pal_ndbi)\n\nMap$centerObject(eeObject = roi_ee,zoom = 12) \nMap$addLayer(S2_NDBI,visParams =viz_ndbi)\n\n\n\n7.3.5 Calcular un índice\n\nmz_sii <- readRDS(\"data/rds/mz_constru_SII.rds\") %>% \n  st_as_sf() %>% \n  filter(n_com == mi_comuna) %>% \n  mutate(id = 1:nrow(.))\n\nExtraer los valores con la función ee_extract cuya documentación se encuentra en el siguiente link\n\n#Extract values - getInfo\nee_com_urb <- ee_extract(\n x = S2_NDBI,\n y = mz_sii[\"id\"],\n scale = 10,\n fun = ee$Reducer$mean(),\n sf = TRUE\n)\n\n\n\n\n\nmz_sii_urb <- mz_sii %>% \n  left_join(ee_com_urb %>% st_drop_geometry(), by = \"id\")\n\n\n\n7.3.6 Corrección\n\nmz_sii_urb <- mz_sii_urb %>% \n  mutate(NDBI = ifelse(total == 0, NA, NDBI))\n\n\n\n7.3.7 Histograma de NDVI\n\nggplot(mz_sii_urb, aes(x = NDBI)) +\n  geom_histogram(bins = 50, fill = \"#1d91c0\", color =\"gray80\")+\n  theme_bw()+\n  labs(title=\"Histograma de Índice de Urbanismo\", x =\"NDBI\", y = \"Frecuencias\")+\n  theme(plot.title = element_text(face = \"bold\",colour= \"gray60\", size=10)) \n\n\n\n\n\n\n7.3.8 Visualización espacial de NDBI\n\nmapview(mz_sii_urb, zcol= \"NDBI\")\n\n\nlibrary(ggplot2)\nlibrary(viridis)\n\n# Visualización ggplot y sf\nggplot() +\n  geom_sf(data = mz_sii_urb, aes(fill = NDBI), alpha=0.7)+\n  scale_fill_viridis_c(option = \"E\", direction = -1)+\n  ggtitle(\"Urban Index: NDBI\") +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"),\n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n7.3.9 Guardar los resultados\n\nsaveRDS(ee_com_urb, file = \"data/rds/ndbi_2016.rds\")"
  },
  {
    "objectID": "tarea_2.html#antecedentes",
    "href": "tarea_2.html#antecedentes",
    "title": "Tarea 2",
    "section": "Antecedentes",
    "text": "Antecedentes\nFecha de Entrega: 22 de Mayo del 2023\nFormato de Entrega: Documento de texto (word, pdf, markdown) + códigos (.R)\nIntegrantes: 2 Personas"
  },
  {
    "objectID": "tarea_2.html#enuncuciado",
    "href": "tarea_2.html#enuncuciado",
    "title": "Tarea 2",
    "section": "Enuncuciado",
    "text": "Enuncuciado\nSe necesita crear un índice normalizado espectral que ustedes decidan utilizando Google Earth Engine, cuya área de estudio corresponderá a la zona urbana de una comuna de Chile que prefieran a nivel de Manzana y analizar su distribución espacial visualmente."
  },
  {
    "objectID": "tarea_2.html#referencias",
    "href": "tarea_2.html#referencias",
    "title": "Tarea 2",
    "section": "Referencias",
    "text": "Referencias\nLearning R for Geoespatial Analysis\nhttps://rspatial.org/raster/spatial/8-rastermanip.html\nhttps://r-spatial.github.io/mapview/"
  },
  {
    "objectID": "tarea_2.html#función-de-índice-sec-findex",
    "href": "tarea_2.html#función-de-índice-sec-findex",
    "title": "Tarea 2",
    "section": "Función de Índice: Section 7.3.3",
    "text": "Función de Índice: Section 7.3.3"
  },
  {
    "objectID": "indices.html#sec-indurb",
    "href": "indices.html#sec-indurb",
    "title": "7  S5: Índices Espectrales",
    "section": "7.2 Índices Urbanos",
    "text": "7.2 Índices Urbanos\nAlgunos ejemplos de índices espectrales normalizados utilizados para analizar el entorno urbano con percepción remota son:\n\nNDBI (Índice de Brillo de la Edificación Normalizado): Este índice se utiliza para identificar y mapear áreas urbanas construidas. Se calcula utilizando la reflectancia en la banda del infrarrojo cercano y la banda del rojo.\nSI (Índice de Suelo): Este índice se utiliza para detectar y mapear la presencia de suelo desnudo en áreas urbanas. Se calcula utilizando la reflectancia en la banda del rojo y la banda del infrarrojo cercano.\n\nEstos índices espectrales normalizados pueden ser útiles para el análisis de la planificación urbana, la gestión del medio ambiente y otros fines relacionados con la ciudad.\nHaciendo uso de proyecto awesome spectral indices que ofrece a los usuarios las herramientas para consultar índices espectrales y las bandas requeridas para el cálculo de un índice. Incluso cuentan con Aplicación web"
  },
  {
    "objectID": "tarea_2.html#tip-función-de-índice-sec-findex",
    "href": "tarea_2.html#tip-función-de-índice-sec-findex",
    "title": "Tarea 2",
    "section": "Tip: Función de Índice: Section 7.3.3",
    "text": "Tip: Función de Índice: Section 7.3.3"
  },
  {
    "objectID": "tarea_2.html#presentación-del-problema",
    "href": "tarea_2.html#presentación-del-problema",
    "title": "Tarea 2",
    "section": "1. Presentación del Problema",
    "text": "1. Presentación del Problema\nIdentifique un problema que desea visibilizar a través de un índice normalizado (, seleccione área de estudio e insumo satelital. Justifique lo anterior. (2 puntos).\n\n\n\n\n\n\nSelección de Índices Section 7.2\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Aplicación web"
  },
  {
    "objectID": "tarea_2.html#cáculo-de-indicador.",
    "href": "tarea_2.html#cáculo-de-indicador.",
    "title": "Tarea 2",
    "section": "2. Cáculo de Indicador.",
    "text": "2. Cáculo de Indicador.\nSiga los siguientes pasos:\n\nAcceda al producto satelital,\nFiltre por fechas, Corte imagen satelital por área de estudio\nConstruya la función de su índice normalizado y aplicar\n\n\n\n\n\n\n\nTip: Producto Satelital y Filtros: Section 7.3.2\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Función de Índice: Section 7.3.3"
  },
  {
    "objectID": "tarea_2.html#interpretación-de-resultados.",
    "href": "tarea_2.html#interpretación-de-resultados.",
    "title": "Tarea 2",
    "section": "3. Interpretación de Resultados.",
    "text": "3. Interpretación de Resultados.\nSiga los siguientes pasos de visualización:\n\nIdentifique si el índice construído requiere que establezca un umbral de corta, si es así aplicar la función.\nVisualice los resultados a través de un mapa dinámico y/ estático\nAnalice los resultados visualmente y realice una conclusión de la distribución espacial de los valores\n\n\n\n\n\n\n\nTip: Visualización del Mapas Section 7.3.8"
  },
  {
    "objectID": "tarea_2.html#presentación-del-problema-2-puntos",
    "href": "tarea_2.html#presentación-del-problema-2-puntos",
    "title": "Tarea 2",
    "section": "1. Presentación del Problema (2 puntos)",
    "text": "1. Presentación del Problema (2 puntos)\nIdentifique un problema que desea visibilizar a través de un índice normalizado (, seleccione área de estudio e insumo satelital. Justifique lo anterior. (2 puntos).\n\n\n\n\n\n\nSelección de Índices Section 7.2\n\n\n\n\n\n\n\n\n\n\n\n\nTip: Aplicación web"
  },
  {
    "objectID": "tarea_2.html#cáculo-de-indicador.-3-puntos",
    "href": "tarea_2.html#cáculo-de-indicador.-3-puntos",
    "title": "Tarea 2",
    "section": "2. Cáculo de Indicador. (3 puntos)",
    "text": "2. Cáculo de Indicador. (3 puntos)\nSiga los siguientes pasos:\n\nAcceda al producto satelital (Section 7.3.2)\nFiltre por fechas, Corte imagen satelital por área de estudio\nConstruya la función de su índice normalizado y aplicar (Section 7.3.3)"
  },
  {
    "objectID": "tarea_2.html#interpretación-de-resultados.-2-puntos",
    "href": "tarea_2.html#interpretación-de-resultados.-2-puntos",
    "title": "Tarea 2",
    "section": "3. Interpretación de Resultados. (2 puntos)",
    "text": "3. Interpretación de Resultados. (2 puntos)\nSiga los siguientes pasos de visualización:\n\nIdentifique si el índice construído requiere que establezca un umbral de corta, si es así aplicar la función.\nVisualice los resultados a través de un mapa dinámico y/ estático\nAnalice los resultados visualmente y realice una conclusión de la distribución espacial de los valores\n\n\n\n\n\n\n\nTip: Visualización del Mapas Section 7.3.8"
  },
  {
    "objectID": "indices.html#referencias",
    "href": "indices.html#referencias",
    "title": "7  S5: Índices Espectrales",
    "section": "7.5 Referencias",
    "text": "7.5 Referencias\n\nA initial approach on how to understand spectral indices\nSpectral indices in remote sensing- part-1\nA standardized catalogue of spectral indices to advance the use of remote sensing in Earth system research"
  },
  {
    "objectID": "index.html#profesor-var-profesor.name",
    "href": "index.html#profesor-var-profesor.name",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "Profesor: Denis Berroeta",
    "text": "Profesor: Denis Berroeta\nCoordinador de Investigación, Centro de Inteligencia Territorial -UAI, email: denis.berroeta@uai.cl\nIngeniero en Prevención de Riesgos, Magíster en Inteligencia Artificial, Doctorado y Master in Data Science (cursando). Experiencia en en Percepción Remota Profesor en Diplomado de Gestión y evidencia Territorial, Servicio Aerofotogramétrico de la Fuerza Aérea de Chile y SII. Tema de Tesis Detección de Cambios en Imágenes Radar con técnicas de deep learning.\nProfesor de cursos y postgrados de Facultad de Gobierno UAI, CIAE de Universidad de Chile, Contraloría General de la República."
  },
  {
    "objectID": "index.html#ayudante-var-ayudante.name",
    "href": "index.html#ayudante-var-ayudante.name",
    "title": "Curso: Análisis de Imágenes Satelitales para SII",
    "section": "Ayudante: Felipe Matas",
    "text": "Ayudante: Felipe Matas\nAnalista de investigación y desarrollo, Centro de Inteligencia Territorial -UAI, email: felipe.matas@edu.uai.cl\nIngeniero Industrial con mención en energía. Levantamiento, implementación y desarrollo de nuevas tecnologías y metodologías, soporte a proyectos.\nExperiencia en programación, desarrollo de soluciones con TI, toma de muestras y análisis de de datos, probabilidades y Kernel Density. Ayudante en Curso de Ciencia de datos espaciales y Diplomado de Diseño territorial basado en evidencia."
  }
]